Below is a complete, functional tutorial that reorders the Supabase setup to come first and now includes a ready-to-run terminal script. This tutorial is designed to be copied and pasted into your terminal (for the shell script portion) and into your code editor for the code files. As always, integrate these changes with your existing system carefully, back up your codebase before major changes, and adhere to established code standards for quality and maintainability.

---

# Table of Contents

- [1. Supabase Integration & Backend Setup](#1-supabase-integration--backend-setup)
  - [1.1 Authentication and Role Assignment](#11-authentication-and-role-assignment)
  - [1.2 Database Schema and API Service Layer](#12-database-schema-and-api-service-layer)
- [2. Initial Expo Setup & Configuration](#2-initial-expo-setup--configuration)
- [3. Building the Admin Dashboard](#3-building-the-admin-dashboard)
- [4. Implementing Social Network Features](#4-implementing-social-network-features)
  - [4.1 Posts Component](#41-posts-component)
  - [4.2 Chat Component](#42-chat-component)
- [5. Developer Experience Tools](#5-developer-experience-tools)
  - [5.1 Storybook Setup](#51-storybook-setup)
  - [5.2 Testing Setup](#52-testing-setup)
- [6. CRUD Scaffolding Interface](#6-crud-scaffolding-interface)
- [7. Terminal Setup Script](#7-terminal-setup-script)

---

## 1. Supabase Integration & Backend Setup

Before setting up your Expo project, begin by configuring Supabase. This section includes SQL commands you must run in your Supabase dashboard as well as the backend service layer files that your Expo project will use.

### 1.1 Authentication and Role Assignment

In your Supabase SQL editor, run the following SQL to create a table for user roles and to automatically assign roles on sign-up. The very first user will be assigned the “admin” role, and all subsequent users will get the “user” role:

```sql
-- Create a table for user roles
create table if not exists public.user_roles (
  user_id uuid primary key,
  role text not null,
  created_at timestamp with time zone default now()
);

-- Create a function to assign roles automatically
create or replace function public.assign_role()
returns trigger as $$
declare
  admin_count int;
begin
  select count(*) into admin_count from public.user_roles where role = 'admin';
  if admin_count = 0 then
    insert into public.user_roles(user_id, role) values (new.id, 'admin');
  else
    insert into public.user_roles(user_id, role) values (new.id, 'user');
  end if;
  return new;
end;
$$ language plpgsql;

-- Create the trigger to call the function after user insertion
drop trigger if exists assign_role_trigger on auth.users;
create trigger assign_role_trigger
after insert on auth.users
for each row execute function public.assign_role();
```

### 1.2 Database Schema and API Service Layer

Also in your Supabase dashboard, create initial tables for posts, chats, and custom CRUD operations:

```sql
-- Create posts table
create table if not exists public.posts (
  id uuid primary key default gen_random_uuid(),
  user_id uuid references auth.users(id),
  content text not null,
  created_at timestamp with time zone default now()
);

-- Create chats table
create table if not exists public.chats (
  id uuid primary key default gen_random_uuid(),
  sender_id uuid references auth.users(id),
  receiver_id uuid references auth.users(id),
  message text not null,
  created_at timestamp with time zone default now()
);

-- Create table for CRUD operations
create table if not exists public.crud_items (
  id uuid primary key default gen_random_uuid(),
  content text not null,
  created_at timestamp with time zone default now()
);
```

Next, in your local codebase (once you create your Expo project), add a file named `apiService.js` for handling API calls with error handling and logging:

```javascript
// apiService.js
import { supabase } from './supabaseClient';

// Posts API
export const fetchPosts = async () => {
  const { data, error } = await supabase
    .from('posts')
    .select('*')
    .order('created_at', { ascending: false });
  if (error) {
    console.error('Error fetching posts:', error);
    throw error;
  }
  return data;
};

export const createPost = async (content) => {
  const { data, error } = await supabase
    .from('posts')
    .insert([{ content }]);
  if (error) {
    console.error('Error creating post:', error);
    throw error;
  }
  return data;
};

// Chats API
export const fetchChats = async () => {
  const { data, error } = await supabase
    .from('chats')
    .select('*')
    .order('created_at');
  if (error) {
    console.error('Error fetching chats:', error);
    throw error;
  }
  return data;
};

export const createChatMessage = async (message) => {
  const { data, error } = await supabase
    .from('chats')
    .insert([{ message }]);
  if (error) {
    console.error('Error creating chat message:', error);
    throw error;
  }
  return data;
};
```

---

## 2. Initial Expo Setup & Configuration

With your Supabase backend in place, initialize your Expo project and create configuration files.

First, run the following commands in your terminal:

```bash
npx create-expo-app ScriptHammer
cd ScriptHammer
npm run reset-project
rm -rf app-example
```

Create a file named `config.js` to store global variables such as the project name and your Supabase credentials:

```javascript
// config.js
export const APP_CONFIG = {
  projectName: 'ScriptHammer',
  // Replace with your actual Supabase credentials:
  supabaseUrl: 'https://your-supabase-url.supabase.co',
  supabaseAnonKey: 'your-supabase-anon-key',
};
```

Then, create your Supabase client file (`supabaseClient.js`) so that it uses the configuration:

```javascript
// supabaseClient.js
import { createClient } from '@supabase/supabase-js';
import { APP_CONFIG } from './config';

const supabaseUrl = APP_CONFIG.supabaseUrl;
const supabaseAnonKey = APP_CONFIG.supabaseAnonKey;

export const supabase = createClient(supabaseUrl, supabaseAnonKey);
```

---

## 3. Building the Admin Dashboard

Develop a role-protected admin dashboard. Create a file named `AdminDashboard.js` that checks the user’s role from context and renders accordingly:

```javascript
// AdminDashboard.js
import React, { useContext } from 'react';
import { View, Text, Button } from 'react-native';
import { UserContext } from './UserContext'; // Ensure you have this context set up

const AdminDashboard = () => {
  const { role } = useContext(UserContext);

  if (role !== 'admin') {
    return (
      <View className="p-4">
        <Text className="text-red-500 text-xl">Access Denied</Text>
        <Text>You do not have admin privileges.</Text>
      </View>
    );
  }

  return (
    <View className="p-4">
      <Text className="text-2xl font-bold mb-4">Admin Dashboard</Text>
      <Button title="Refresh Data" onPress={() => { /* Refresh logic here */ }} />
    </View>
  );
};

export default AdminDashboard;
```

*Reminder: Integrate this dashboard with your navigation system and ensure your user context is correctly provided throughout the app.*

---

## 4. Implementing Social Network Features

### 4.1 Posts Component

Create a `PostList.js` component that fetches and displays posts while allowing users to create new posts:

```javascript
// PostList.js
import React, { useEffect, useState } from 'react';
import { View, Text, FlatList, Button } from 'react-native';
import { fetchPosts, createPost } from './apiService';

const PostList = () => {
  const [posts, setPosts] = useState([]);

  const loadPosts = async () => {
    try {
      const data = await fetchPosts();
      setPosts(data);
    } catch (error) {
      console.error('Error loading posts:', error);
    }
  };

  useEffect(() => {
    loadPosts();
  }, []);

  return (
    <View className="p-4">
      <Text className="text-2xl font-bold mb-4">Posts</Text>
      <FlatList
        data={posts}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <View className="mb-2 p-2 border rounded">
            <Text>{item.content}</Text>
          </View>
        )}
      />
      <Button title="New Post" onPress={() => createPost("Sample post content").then(loadPosts)} />
    </View>
  );
};

export default PostList;
```

### 4.2 Chat Component

Develop a real-time chat interface in `ChatComponent.js` using Supabase subscriptions:

```javascript
// ChatComponent.js
import React, { useEffect, useState } from 'react';
import { View, Text, FlatList, TextInput, Button } from 'react-native';
import { supabase } from './supabaseClient';
import { createChatMessage, fetchChats } from './apiService';

const ChatComponent = () => {
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState('');

  const loadMessages = async () => {
    try {
      const data = await fetchChats();
      setMessages(data);
    } catch (error) {
      console.error('Error loading messages:', error);
    }
  };

  const sendMessage = async () => {
    if (!newMessage) return;
    try {
      await createChatMessage(newMessage);
      setNewMessage('');
    } catch (error) {
      console.error('Error sending message:', error);
    }
  };

  useEffect(() => {
    loadMessages();
    const subscription = supabase
      .from('chats')
      .on('INSERT', payload => {
        setMessages((prev) => [...prev, payload.new]);
      })
      .subscribe();

    return () => {
      supabase.removeSubscription(subscription);
    };
  }, []);

  return (
    <View className="p-4">
      <Text className="text-2xl font-bold mb-4">Chat</Text>
      <FlatList
        data={messages}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <View className="mb-2 p-2 border rounded">
            <Text>{item.message}</Text>
          </View>
        )}
      />
      <TextInput 
        value={newMessage}
        onChangeText={setNewMessage}
        placeholder="Type your message..."
        className="border p-2 mb-2"
      />
      <Button title="Send" onPress={sendMessage} />
    </View>
  );
};

export default ChatComponent;
```

---

## 5. Developer Experience Tools

### 5.1 Storybook Setup

Set up Storybook for isolated UI component development. Create a `.storybook/main.js` file with the following content:

```javascript
// .storybook/main.js
module.exports = {
  stories: ['../components/**/*.stories.@(js|jsx|ts|tsx)'],
  addons: [
    '@storybook/addon-links',
    '@storybook/addon-essentials',
  ],
};
```

Add an initial story for a Button component in `components/Button.stories.js`:

```javascript
// components/Button.stories.js
import React from 'react';
import { Button } from 'react-native';
import { storiesOf } from '@storybook/react-native';

storiesOf('Button', module)
  .add('default', () => (
    <Button title="Click Me" onPress={() => {}} />
  ));
```

### 5.2 Testing Setup

Configure Jest for testing your critical application paths. Create a test file `App.test.js` to capture a snapshot of your main App component:

```javascript
// App.test.js
import React from 'react';
import renderer from 'react-test-renderer';
import App from './App';

it('renders correctly', () => {
  const tree = renderer.create(<App />).toJSON();
  expect(tree).toMatchSnapshot();
});
```

Also, add a Jest configuration file (`jest.config.js`):

```javascript
// jest.config.js
module.exports = {
  preset: 'jest-expo',
  transform: {
    '^.+\\.js$': '<rootDir>/node_modules/react-native/jest/preprocessor.js',
  },
  setupFiles: ['./jest.setup.js'],
};
```

And a simple Jest setup file (`jest.setup.js`):

```javascript
// jest.setup.js
import 'react-native-gesture-handler/jestSetup';
```

---

## 6. CRUD Scaffolding Interface

Create a dynamic CRUD interface that interacts with the `crud_items` table in Supabase. Save the following code as `CrudInterface.js`:

```javascript
// CrudInterface.js
import React, { useState, useEffect } from 'react';
import { View, Text, TextInput, Button, FlatList } from 'react-native';
import { supabase } from './supabaseClient';

const CrudInterface = () => {
  const [items, setItems] = useState([]);
  const [newItem, setNewItem] = useState('');
  const [editItemId, setEditItemId] = useState(null);
  const [editText, setEditText] = useState('');

  const fetchItems = async () => {
    const { data, error } = await supabase
      .from('crud_items')
      .select('*')
      .order('created_at', { ascending: false });
    if (error) {
      console.error('Error fetching items:', error);
    } else {
      setItems(data);
    }
  };

  const createItem = async () => {
    if (!newItem) return;
    const { data, error } = await supabase
      .from('crud_items')
      .insert([{ content: newItem }]);
    if (error) {
      console.error('Error creating item:', error);
    } else {
      setNewItem('');
      fetchItems();
    }
  };

  const updateItem = async () => {
    if (!editText || !editItemId) return;
    const { data, error } = await supabase
      .from('crud_items')
      .update({ content: editText })
      .eq('id', editItemId);
    if (error) {
      console.error('Error updating item:', error);
    } else {
      setEditItemId(null);
      setEditText('');
      fetchItems();
    }
  };

  const deleteItem = async (id) => {
    const { data, error } = await supabase
      .from('crud_items')
      .delete()
      .eq('id', id);
    if (error) {
      console.error('Error deleting item:', error);
    } else {
      fetchItems();
    }
  };

  useEffect(() => {
    fetchItems();
  }, []);

  return (
    <View className="p-4">
      <Text className="text-2xl font-bold mb-4">CRUD Scaffolding Interface</Text>
      <TextInput 
        value={newItem}
        onChangeText={setNewItem}
        placeholder="New item content"
        className="border p-2 mb-2"
      />
      <Button title="Add Item" onPress={createItem} />
      <FlatList
        data={items}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <View className="my-2 p-2 border rounded">
            <Text>{item.content}</Text>
            <Button title="Edit" onPress={() => { setEditItemId(item.id); setEditText(item.content); }} />
            <Button title="Delete" onPress={() => deleteItem(item.id)} />
          </View>
        )}
      />
      {editItemId && (
        <View className="mt-4">
          <Text>Edit Item</Text>
          <TextInput 
            value={editText}
            onChangeText={setEditText}
            placeholder="Edit item content"
            className="border p-2 mb-2"
          />
          <Button title="Update Item" onPress={updateItem} />
        </View>
      )}
    </View>
  );
};

export default CrudInterface;
```

*Reminder: Integrate the CRUD interface with your navigation and styling systems, and always preserve the integrity of your existing codebase.*

---

## 7. Terminal Setup Script

To help you quickly recreate this project structure (excluding the Supabase SQL commands which must be run separately in your Supabase dashboard), copy and paste the following shell script into your terminal. This script initializes the Expo project and creates all the necessary files with the complete code blocks shown above.

```bash
#!/bin/bash
# --- Terminal Setup Script for ScriptHammer Mobile App Framework ---

# Step 1: Create and setup the Expo project
npx create-expo-app ScriptHammer
cd ScriptHammer
npm run reset-project
rm -rf app-example

# Step 2: Create configuration and Supabase client files
cat > config.js << 'EOF'
export const APP_CONFIG = {
  projectName: 'ScriptHammer',
  // Replace with your actual Supabase credentials:
  supabaseUrl: 'https://your-supabase-url.supabase.co',
  supabaseAnonKey: 'your-supabase-anon-key',
};
EOF

cat > supabaseClient.js << 'EOF'
import { createClient } from '@supabase/supabase-js';
import { APP_CONFIG } from './config';

const supabaseUrl = APP_CONFIG.supabaseUrl;
const supabaseAnonKey = APP_CONFIG.supabaseAnonKey;

export const supabase = createClient(supabaseUrl, supabaseAnonKey);
EOF

# Step 3: Create the API service layer file
cat > apiService.js << 'EOF'
import { supabase } from './supabaseClient';

// Posts API
export const fetchPosts = async () => {
  const { data, error } = await supabase.from('posts').select('*').order('created_at', { ascending: false });
  if (error) {
    console.error('Error fetching posts:', error);
    throw error;
  }
  return data;
};

export const createPost = async (content) => {
  const { data, error } = await supabase.from('posts').insert([{ content }]);
  if (error) {
    console.error('Error creating post:', error);
    throw error;
  }
  return data;
};

// Chats API
export const fetchChats = async () => {
  const { data, error } = await supabase.from('chats').select('*').order('created_at');
  if (error) {
    console.error('Error fetching chats:', error);
    throw error;
  }
  return data;
};

export const createChatMessage = async (message) => {
  const { data, error } = await supabase.from('chats').insert([{ message }]);
  if (error) {
    console.error('Error creating chat message:', error);
    throw error;
  }
  return data;
};
EOF

# Step 4: Create component files

cat > AdminDashboard.js << 'EOF'
import React, { useContext } from 'react';
import { View, Text, Button } from 'react-native';
import { UserContext } from './UserContext';

const AdminDashboard = () => {
  const { role } = useContext(UserContext);

  if (role !== 'admin') {
    return (
      <View className="p-4">
        <Text className="text-red-500 text-xl">Access Denied</Text>
        <Text>You do not have admin privileges.</Text>
      </View>
    );
  }

  return (
    <View className="p-4">
      <Text className="text-2xl font-bold mb-4">Admin Dashboard</Text>
      <Button title="Refresh Data" onPress={() => { /* Refresh logic here */ }} />
    </View>
  );
};

export default AdminDashboard;
EOF

cat > PostList.js << 'EOF'
import React, { useEffect, useState } from 'react';
import { View, Text, FlatList, Button } from 'react-native';
import { fetchPosts, createPost } from './apiService';

const PostList = () => {
  const [posts, setPosts] = useState([]);

  const loadPosts = async () => {
    try {
      const data = await fetchPosts();
      setPosts(data);
    } catch (error) {
      console.error('Error loading posts:', error);
    }
  };

  useEffect(() => {
    loadPosts();
  }, []);

  return (
    <View className="p-4">
      <Text className="text-2xl font-bold mb-4">Posts</Text>
      <FlatList
        data={posts}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <View className="mb-2 p-2 border rounded">
            <Text>{item.content}</Text>
          </View>
        )}
      />
      <Button title="New Post" onPress={() => createPost("Sample post content").then(loadPosts)} />
    </View>
  );
};

export default PostList;
EOF

cat > ChatComponent.js << 'EOF'
import React, { useEffect, useState } from 'react';
import { View, Text, FlatList, TextInput, Button } from 'react-native';
import { supabase } from './supabaseClient';
import { createChatMessage, fetchChats } from './apiService';

const ChatComponent = () => {
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState('');

  const loadMessages = async () => {
    try {
      const data = await fetchChats();
      setMessages(data);
    } catch (error) {
      console.error('Error loading messages:', error);
    }
  };

  const sendMessage = async () => {
    if (!newMessage) return;
    try {
      await createChatMessage(newMessage);
      setNewMessage('');
    } catch (error) {
      console.error('Error sending message:', error);
    }
  };

  useEffect(() => {
    loadMessages();
    const subscription = supabase
      .from('chats')
      .on('INSERT', payload => {
        setMessages((prev) => [...prev, payload.new]);
      })
      .subscribe();

    return () => {
      supabase.removeSubscription(subscription);
    };
  }, []);

  return (
    <View className="p-4">
      <Text className="text-2xl font-bold mb-4">Chat</Text>
      <FlatList
        data={messages}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <View className="mb-2 p-2 border rounded">
            <Text>{item.message}</Text>
          </View>
        )}
      />
      <TextInput 
        value={newMessage}
        onChangeText={setNewMessage}
        placeholder="Type your message..."
        className="border p-2 mb-2"
      />
      <Button title="Send" onPress={sendMessage} />
    </View>
  );
};

export default ChatComponent;
EOF

cat > CrudInterface.js << 'EOF'
import React, { useState, useEffect } from 'react';
import { View, Text, TextInput, Button, FlatList } from 'react-native';
import { supabase } from './supabaseClient';

const CrudInterface = () => {
  const [items, setItems] = useState([]);
  const [newItem, setNewItem] = useState('');
  const [editItemId, setEditItemId] = useState(null);
  const [editText, setEditText] = useState('');

  const fetchItems = async () => {
    const { data, error } = await supabase
      .from('crud_items')
      .select('*')
      .order('created_at', { ascending: false });
    if (error) {
      console.error('Error fetching items:', error);
    } else {
      setItems(data);
    }
  };

  const createItem = async () => {
    if (!newItem) return;
    const { data, error } = await supabase
      .from('crud_items')
      .insert([{ content: newItem }]);
    if (error) {
      console.error('Error creating item:', error);
    } else {
      setNewItem('');
      fetchItems();
    }
  };

  const updateItem = async () => {
    if (!editText || !editItemId) return;
    const { data, error } = await supabase
      .from('crud_items')
      .update({ content: editText })
      .eq('id', editItemId);
    if (error) {
      console.error('Error updating item:', error);
    } else {
      setEditItemId(null);
      setEditText('');
      fetchItems();
    }
  };

  const deleteItem = async (id) => {
    const { data, error } = await supabase
      .from('crud_items')
      .delete()
      .eq('id', id);
    if (error) {
      console.error('Error deleting item:', error);
    } else {
      fetchItems();
    }
  };

  useEffect(() => {
    fetchItems();
  }, []);

  return (
    <View className="p-4">
      <Text className="text-2xl font-bold mb-4">CRUD Scaffolding Interface</Text>
      <TextInput 
        value={newItem}
        onChangeText={setNewItem}
        placeholder="New item content"
        className="border p-2 mb-2"
      />
      <Button title="Add Item" onPress={createItem} />
      <FlatList
        data={items}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <View className="my-2 p-2 border rounded">
            <Text>{item.content}</Text>
            <Button title="Edit" onPress={() => { setEditItemId(item.id); setEditText(item.content); }} />
            <Button title="Delete" onPress={() => deleteItem(item.id)} />
          </View>
        )}
      />
      {editItemId && (
        <View className="mt-4">
          <Text>Edit Item</Text>
          <TextInput 
            value={editText}
            onChangeText={setEditText}
            placeholder="Edit item content"
            className="border p-2 mb-2"
          />
          <Button title="Update Item" onPress={updateItem} />
        </View>
      )}
    </View>
  );
};

export default CrudInterface;
EOF

echo "Project setup complete."
echo "IMPORTANT: Please run the Supabase SQL commands provided in Section 1 of this tutorial in your Supabase dashboard to set up authentication, roles, and database schema."
```

---

By following this tutorial step by step, you will have a robust mobile app framework that integrates Supabase for backend operations, uses Expo for the front end, applies NativeWind for styling (with system-based dark/light toggling), includes Storybook for UI development, and implements testing with Jest. Always ensure that you integrate each module carefully with your existing system and adhere to established codebase standards for a maintainable and high-quality project.

Happy coding, and remember to test incrementally and document your changes along the way!
