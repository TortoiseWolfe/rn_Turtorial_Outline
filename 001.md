Below is the revised, complete tutorial with a fully clickable table of contents and a terminal script. In this version, the Supabase setup is placed first, and the configuration file now uses the proper environment variable naming format—leveraging the provided full values. Copy and paste the terminal script to recreate the project structure, and then integrate the code files into your code editor. Remember to back up your existing code and integrate carefully with your system while maintaining codebase standards.

---

# Table of Contents

- [1. Supabase Integration & Backend Setup](#1-supabase-integration--backend-setup)
  - [1.1 Authentication and Role Assignment](#11-authentication-and-role-assignment)
  - [1.2 Database Schema and API Service Layer](#12-database-schema-and-api-service-layer)
- [2. Initial Expo Setup & Configuration](#2-initial-expo-setup--configuration)
- [3. Building the Admin Dashboard](#3-building-the-admin-dashboard)
- [4. Implementing Social Network Features](#4-implementing-social-network-features)
  - [4.1 Posts Component](#41-posts-component)
  - [4.2 Chat Component](#42-chat-component)
- [5. Developer Experience Tools](#5-developer-experience-tools)
  - [5.1 Storybook Setup](#51-storybook-setup)
  - [5.2 Testing Setup](#52-testing-setup)
- [6. CRUD Scaffolding Interface](#6-crud-scaffolding-interface)
- [7. Terminal Setup Script](#7-terminal-setup-script)

---

## 1. Supabase Integration & Backend Setup

Before you set up your Expo project, configure your Supabase backend. Run the following SQL commands in your Supabase dashboard to create the necessary tables and functions.

### 1.1 Authentication and Role Assignment

This SQL script creates a table to store user roles and a trigger to automatically assign the “admin” role to the first user and “user” for all subsequent sign-ups.

```sql
-- Create a table for user roles
create table if not exists public.user_roles (
  user_id uuid primary key,
  role text not null,
  created_at timestamp with time zone default now()
);

-- Create a function to assign roles automatically
create or replace function public.assign_role()
returns trigger as $$
declare
  admin_count int;
begin
  select count(*) into admin_count from public.user_roles where role = 'admin';
  if admin_count = 0 then
    insert into public.user_roles(user_id, role) values (new.id, 'admin');
  else
    insert into public.user_roles(user_id, role) values (new.id, 'user');
  end if;
  return new;
end;
$$ language plpgsql;

-- Create the trigger to call the function after user insertion
drop trigger if exists assign_role_trigger on auth.users;
create trigger assign_role_trigger
after insert on auth.users
for each row execute function public.assign_role();
```

### 1.2 Database Schema and API Service Layer

Create your initial tables for posts, chats, and CRUD operations by executing these SQL commands in your Supabase dashboard:

```sql
-- Create posts table
create table if not exists public.posts (
  id uuid primary key default gen_random_uuid(),
  user_id uuid references auth.users(id),
  content text not null,
  created_at timestamp with time zone default now()
);

-- Create chats table
create table if not exists public.chats (
  id uuid primary key default gen_random_uuid(),
  sender_id uuid references auth.users(id),
  receiver_id uuid references auth.users(id),
  message text not null,
  created_at timestamp with time zone default now()
);

-- Create table for CRUD operations
create table if not exists public.crud_items (
  id uuid primary key default gen_random_uuid(),
  content text not null,
  created_at timestamp with time zone default now()
);
```

Next, build a robust API service layer in your local project. Create an `apiService.js` file with proper error handling:

```javascript
// apiService.js
import { supabase } from './supabaseClient';

// Posts API
export const fetchPosts = async () => {
  const { data, error } = await supabase
    .from('posts')
    .select('*')
    .order('created_at', { ascending: false });
  if (error) {
    console.error('Error fetching posts:', error);
    throw error;
  }
  return data;
};

export const createPost = async (content) => {
  const { data, error } = await supabase
    .from('posts')
    .insert([{ content }]);
  if (error) {
    console.error('Error creating post:', error);
    throw error;
  }
  return data;
};

// Chats API
export const fetchChats = async () => {
  const { data, error } = await supabase
    .from('chats')
    .select('*')
    .order('created_at');
  if (error) {
    console.error('Error fetching chats:', error);
    throw error;
  }
  return data;
};

export const createChatMessage = async (message) => {
  const { data, error } = await supabase
    .from('chats')
    .insert([{ message }]);
  if (error) {
    console.error('Error creating chat message:', error);
    throw error;
  }
  return data;
};
```

---

## 2. Initial Expo Setup & Configuration

Now that your backend is ready, initialize your Expo project and set up configuration files. First, run these commands in your terminal:

```bash
npx create-expo-app ScriptHammer
cd ScriptHammer
npm run reset-project
rm -rf app-example
```

Create a file named `config.js` to store global variables. This file uses the proper environment variable names—`EXPO_PUBLIC_SUPABASE_URL` and `EXPO_PUBLIC_SUPABASE_ANON_KEY`—with your provided full values. In production, you should store these in a secure environment file and load them appropriately.

```javascript
// config.js
export const APP_CONFIG = {
  projectName: 'ScriptHammer',
  supabaseUrl: process.env.EXPO_PUBLIC_SUPABASE_URL || 'https://wbltsbyjnyraeaqumkcu.supabase.co',
  supabaseAnonKey: process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndibHRzYnlqbnlyYWVhcXVta2N1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzgzNzM1ODksImV4cCI6MjA1Mzk0OTU4OX0.gMqIQ7xIC2zSiwDbbdt6RClZMIkSDQqIJxYzAtdcziY',
};
```

Then, create your Supabase client file (`supabaseClient.js`) to initialize the connection using the configuration:

```javascript
// supabaseClient.js
import { createClient } from '@supabase/supabase-js';
import { APP_CONFIG } from './config';

const supabaseUrl = APP_CONFIG.supabaseUrl;
const supabaseAnonKey = APP_CONFIG.supabaseAnonKey;

export const supabase = createClient(supabaseUrl, supabaseAnonKey);
```

---

## 3. Building the Admin Dashboard

Develop a secure, role-protected admin dashboard. Create an `AdminDashboard.js` component that checks the user’s role (assumed to be provided via context) before rendering:

```javascript
// AdminDashboard.js
import React, { useContext } from 'react';
import { View, Text, Button } from 'react-native';
import { UserContext } from './UserContext'; // Ensure you have this context set up

const AdminDashboard = () => {
  const { role } = useContext(UserContext);

  if (role !== 'admin') {
    return (
      <View className="p-4">
        <Text className="text-red-500 text-xl">Access Denied</Text>
        <Text>You do not have admin privileges.</Text>
      </View>
    );
  }

  return (
    <View className="p-4">
      <Text className="text-2xl font-bold mb-4">Admin Dashboard</Text>
      <Button title="Refresh Data" onPress={() => { /* Refresh logic here */ }} />
    </View>
  );
};

export default AdminDashboard;
```

*Reminder: Integrate this component carefully with your existing navigation and user context for seamless role-based access control.*

---

## 4. Implementing Social Network Features

### 4.1 Posts Component

Create a `PostList.js` component that fetches and displays posts and allows the user to create a new post. Note the use of NativeWind classes for styling.

```javascript
// PostList.js
import React, { useEffect, useState } from 'react';
import { View, Text, FlatList, Button } from 'react-native';
import { fetchPosts, createPost } from './apiService';

const PostList = () => {
  const [posts, setPosts] = useState([]);

  const loadPosts = async () => {
    try {
      const data = await fetchPosts();
      setPosts(data);
    } catch (error) {
      console.error('Error loading posts:', error);
    }
  };

  useEffect(() => {
    loadPosts();
  }, []);

  return (
    <View className="p-4">
      <Text className="text-2xl font-bold mb-4">Posts</Text>
      <FlatList
        data={posts}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <View className="mb-2 p-2 border rounded">
            <Text>{item.content}</Text>
          </View>
        )}
      />
      <Button title="New Post" onPress={() => createPost("Sample post content").then(loadPosts)} />
    </View>
  );
};

export default PostList;
```

### 4.2 Chat Component

Develop a `ChatComponent.js` that handles real-time updates using Supabase subscriptions:

```javascript
// ChatComponent.js
import React, { useEffect, useState } from 'react';
import { View, Text, FlatList, TextInput, Button } from 'react-native';
import { supabase } from './supabaseClient';
import { createChatMessage, fetchChats } from './apiService';

const ChatComponent = () => {
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState('');

  const loadMessages = async () => {
    try {
      const data = await fetchChats();
      setMessages(data);
    } catch (error) {
      console.error('Error loading messages:', error);
    }
  };

  const sendMessage = async () => {
    if (!newMessage) return;
    try {
      await createChatMessage(newMessage);
      setNewMessage('');
    } catch (error) {
      console.error('Error sending message:', error);
    }
  };

  useEffect(() => {
    loadMessages();
    const subscription = supabase
      .from('chats')
      .on('INSERT', payload => {
        setMessages((prev) => [...prev, payload.new]);
      })
      .subscribe();

    return () => {
      supabase.removeSubscription(subscription);
    };
  }, []);

  return (
    <View className="p-4">
      <Text className="text-2xl font-bold mb-4">Chat</Text>
      <FlatList
        data={messages}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <View className="mb-2 p-2 border rounded">
            <Text>{item.message}</Text>
          </View>
        )}
      />
      <TextInput 
        value={newMessage}
        onChangeText={setNewMessage}
        placeholder="Type your message..."
        className="border p-2 mb-2"
      />
      <Button title="Send" onPress={sendMessage} />
    </View>
  );
};

export default ChatComponent;
```

---

## 5. Developer Experience Tools

### 5.1 Storybook Setup

Set up Storybook for isolated UI component development. Create a `.storybook/main.js` file:

```javascript
// .storybook/main.js
module.exports = {
  stories: ['../components/**/*.stories.@(js|jsx|ts|tsx)'],
  addons: [
    '@storybook/addon-links',
    '@storybook/addon-essentials',
  ],
};
```

Add an initial story for a Button component in `components/Button.stories.js`:

```javascript
// components/Button.stories.js
import React from 'react';
import { Button } from 'react-native';
import { storiesOf } from '@storybook/react-native';

storiesOf('Button', module)
  .add('default', () => (
    <Button title="Click Me" onPress={() => {}} />
  ));
```

### 5.2 Testing Setup

Configure Jest for testing your critical application paths. Create a test file (`App.test.js`) to capture a snapshot of your main App component:

```javascript
// App.test.js
import React from 'react';
import renderer from 'react-test-renderer';
import App from './App';

it('renders correctly', () => {
  const tree = renderer.create(<App />).toJSON();
  expect(tree).toMatchSnapshot();
});
```

Also, add a Jest configuration file (`jest.config.js`):

```javascript
// jest.config.js
module.exports = {
  preset: 'jest-expo',
  transform: {
    '^.+\\.js$': '<rootDir>/node_modules/react-native/jest/preprocessor.js',
  },
  setupFiles: ['./jest.setup.js'],
};
```

And a simple Jest setup file (`jest.setup.js`):

```javascript
// jest.setup.js
import 'react-native-gesture-handler/jestSetup';
```

---

## 6. CRUD Scaffolding Interface

Create a dynamic CRUD interface that interacts with the `crud_items` table. Save the following code as `CrudInterface.js`:

```javascript
// CrudInterface.js
import React, { useState, useEffect } from 'react';
import { View, Text, TextInput, Button, FlatList } from 'react-native';
import { supabase } from './supabaseClient';

const CrudInterface = () => {
  const [items, setItems] = useState([]);
  const [newItem, setNewItem] = useState('');
  const [editItemId, setEditItemId] = useState(null);
  const [editText, setEditText] = useState('');

  const fetchItems = async () => {
    const { data, error } = await supabase
      .from('crud_items')
      .select('*')
      .order('created_at', { ascending: false });
    if (error) {
      console.error('Error fetching items:', error);
    } else {
      setItems(data);
    }
  };

  const createItem = async () => {
    if (!newItem) return;
    const { data, error } = await supabase
      .from('crud_items')
      .insert([{ content: newItem }]);
    if (error) {
      console.error('Error creating item:', error);
    } else {
      setNewItem('');
      fetchItems();
    }
  };

  const updateItem = async () => {
    if (!editText || !editItemId) return;
    const { data, error } = await supabase
      .from('crud_items')
      .update({ content: editText })
      .eq('id', editItemId);
    if (error) {
      console.error('Error updating item:', error);
    } else {
      setEditItemId(null);
      setEditText('');
      fetchItems();
    }
  };

  const deleteItem = async (id) => {
    const { data, error } = await supabase
      .from('crud_items')
      .delete()
      .eq('id', id);
    if (error) {
      console.error('Error deleting item:', error);
    } else {
      fetchItems();
    }
  };

  useEffect(() => {
    fetchItems();
  }, []);

  return (
    <View className="p-4">
      <Text className="text-2xl font-bold mb-4">CRUD Scaffolding Interface</Text>
      <TextInput 
        value={newItem}
        onChangeText={setNewItem}
        placeholder="New item content"
        className="border p-2 mb-2"
      />
      <Button title="Add Item" onPress={createItem} />
      <FlatList
        data={items}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <View className="my-2 p-2 border rounded">
            <Text>{item.content}</Text>
            <Button title="Edit" onPress={() => { setEditItemId(item.id); setEditText(item.content); }} />
            <Button title="Delete" onPress={() => deleteItem(item.id)} />
          </View>
        )}
      />
      {editItemId && (
        <View className="mt-4">
          <Text>Edit Item</Text>
          <TextInput 
            value={editText}
            onChangeText={setEditText}
            placeholder="Edit item content"
            className="border p-2 mb-2"
          />
          <Button title="Update Item" onPress={updateItem} />
        </View>
      )}
    </View>
  );
};

export default CrudInterface;
```

*Reminder: Integrate the CRUD interface with your navigation and styling systems, and maintain the integrity of your existing codebase.*

---

## 7. Terminal Setup Script

Use the following shell script to quickly set up your project structure. This script initializes the Expo project and creates all necessary files with the complete code blocks from this tutorial. (Note: Run the Supabase SQL commands manually in your Supabase dashboard.)

```bash
#!/bin/bash
# --- Terminal Setup Script for ScriptHammer Mobile App Framework ---

# Step 1: Create and setup the Expo project
npx create-expo-app ScriptHammer
cd ScriptHammer
npm run reset-project
rm -rf app-example

# Step 2: Create configuration and Supabase client files
cat > config.js << 'EOF'
export const APP_CONFIG = {
  projectName: 'ScriptHammer',
  supabaseUrl: process.env.EXPO_PUBLIC_SUPABASE_URL || 'https://wbltsbyjnyraeaqumkcu.supabase.co',
  supabaseAnonKey: process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndibHRzYnlqbnlyYWVhcXVta2N1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzgzNzM1ODksImV4cCI6MjA1Mzk0OTU4OX0.gMqIQ7xIC2zSiwDbbdt6RClZMIkSDQqIJxYzAtdcziY',
};
EOF

cat > supabaseClient.js << 'EOF'
import { createClient } from '@supabase/supabase-js';
import { APP_CONFIG } from './config';

const supabaseUrl = APP_CONFIG.supabaseUrl;
const supabaseAnonKey = APP_CONFIG.supabaseAnonKey;

export const supabase = createClient(supabaseUrl, supabaseAnonKey);
EOF

# Step 3: Create the API service layer file
cat > apiService.js << 'EOF'
import { supabase } from './supabaseClient';

// Posts API
export const fetchPosts = async () => {
  const { data, error } = await supabase.from('posts').select('*').order('created_at', { ascending: false });
  if (error) {
    console.error('Error fetching posts:', error);
    throw error;
  }
  return data;
};

export const createPost = async (content) => {
  const { data, error } = await supabase.from('posts').insert([{ content }]);
  if (error) {
    console.error('Error creating post:', error);
    throw error;
  }
  return data;
};

// Chats API
export const fetchChats = async () => {
  const { data, error } = await supabase.from('chats').select('*').order('created_at');
  if (error) {
    console.error('Error fetching chats:', error);
    throw error;
  }
  return data;
};

export const createChatMessage = async (message) => {
  const { data, error } = await supabase.from('chats').insert([{ message }]);
  if (error) {
    console.error('Error creating chat message:', error);
    throw error;
  }
  return data;
};
EOF

# Step 4: Create component files

cat > AdminDashboard.js << 'EOF'
import React, { useContext } from 'react';
import { View, Text, Button } from 'react-native';
import { UserContext } from './UserContext';

const AdminDashboard = () => {
  const { role } = useContext(UserContext);

  if (role !== 'admin') {
    return (
      <View className="p-4">
        <Text className="text-red-500 text-xl">Access Denied</Text>
        <Text>You do not have admin privileges.</Text>
      </View>
    );
  }

  return (
    <View className="p-4">
      <Text className="text-2xl font-bold mb-4">Admin Dashboard</Text>
      <Button title="Refresh Data" onPress={() => { /* Refresh logic here */ }} />
    </View>
  );
};

export default AdminDashboard;
EOF

cat > PostList.js << 'EOF'
import React, { useEffect, useState } from 'react';
import { View, Text, FlatList, Button } from 'react-native';
import { fetchPosts, createPost } from './apiService';

const PostList = () => {
  const [posts, setPosts] = useState([]);

  const loadPosts = async () => {
    try {
      const data = await fetchPosts();
      setPosts(data);
    } catch (error) {
      console.error('Error loading posts:', error);
    }
  };

  useEffect(() => {
    loadPosts();
  }, []);

  return (
    <View className="p-4">
      <Text className="text-2xl font-bold mb-4">Posts</Text>
      <FlatList
        data={posts}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <View className="mb-2 p-2 border rounded">
            <Text>{item.content}</Text>
          </View>
        )}
      />
      <Button title="New Post" onPress={() => createPost("Sample post content").then(loadPosts)} />
    </View>
  );
};

export default PostList;
EOF

cat > ChatComponent.js << 'EOF'
import React, { useEffect, useState } from 'react';
import { View, Text, FlatList, TextInput, Button } from 'react-native';
import { supabase } from './supabaseClient';
import { createChatMessage, fetchChats } from './apiService';

const ChatComponent = () => {
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState('');

  const loadMessages = async () => {
    try {
      const data = await fetchChats();
      setMessages(data);
    } catch (error) {
      console.error('Error loading messages:', error);
    }
  };

  const sendMessage = async () => {
    if (!newMessage) return;
    try {
      await createChatMessage(newMessage);
      setNewMessage('');
    } catch (error) {
      console.error('Error sending message:', error);
    }
  };

  useEffect(() => {
    loadMessages();
    const subscription = supabase
      .from('chats')
      .on('INSERT', payload => {
        setMessages((prev) => [...prev, payload.new]);
      })
      .subscribe();

    return () => {
      supabase.removeSubscription(subscription);
    };
  }, []);

  return (
    <View className="p-4">
      <Text className="text-2xl font-bold mb-4">Chat</Text>
      <FlatList
        data={messages}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <View className="mb-2 p-2 border rounded">
            <Text>{item.message}</Text>
          </View>
        )}
      />
      <TextInput 
        value={newMessage}
        onChangeText={setNewMessage}
        placeholder="Type your message..."
        className="border p-2 mb-2"
      />
      <Button title="Send" onPress={sendMessage} />
    </View>
  );
};

export default ChatComponent;
EOF

cat > CrudInterface.js << 'EOF'
import React, { useState, useEffect } from 'react';
import { View, Text, TextInput, Button, FlatList } from 'react-native';
import { supabase } from './supabaseClient';

const CrudInterface = () => {
  const [items, setItems] = useState([]);
  const [newItem, setNewItem] = useState('');
  const [editItemId, setEditItemId] = useState(null);
  const [editText, setEditText] = useState('');

  const fetchItems = async () => {
    const { data, error } = await supabase
      .from('crud_items')
      .select('*')
      .order('created_at', { ascending: false });
    if (error) {
      console.error('Error fetching items:', error);
    } else {
      setItems(data);
    }
  };

  const createItem = async () => {
    if (!newItem) return;
    const { data, error } = await supabase
      .from('crud_items')
      .insert([{ content: newItem }]);
    if (error) {
      console.error('Error creating item:', error);
    } else {
      setNewItem('');
      fetchItems();
    }
  };

  const updateItem = async () => {
    if (!editText || !editItemId) return;
    const { data, error } = await supabase
      .from('crud_items')
      .update({ content: editText })
      .eq('id', editItemId);
    if (error) {
      console.error('Error updating item:', error);
    } else {
      setEditItemId(null);
      setEditText('');
      fetchItems();
    }
  };

  const deleteItem = async (id) => {
    const { data, error } = await supabase
      .from('crud_items')
      .delete()
      .eq('id', id);
    if (error) {
      console.error('Error deleting item:', error);
    } else {
      fetchItems();
    }
  };

  useEffect(() => {
    fetchItems();
  }, []);

  return (
    <View className="p-4">
      <Text className="text-2xl font-bold mb-4">CRUD Scaffolding Interface</Text>
      <TextInput 
        value={newItem}
        onChangeText={setNewItem}
        placeholder="New item content"
        className="border p-2 mb-2"
      />
      <Button title="Add Item" onPress={createItem} />
      <FlatList
        data={items}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <View className="my-2 p-2 border rounded">
            <Text>{item.content}</Text>
            <Button title="Edit" onPress={() => { setEditItemId(item.id); setEditText(item.content); }} />
            <Button title="Delete" onPress={() => deleteItem(item.id)} />
          </View>
        )}
      />
      {editItemId && (
        <View className="mt-4">
          <Text>Edit Item</Text>
          <TextInput 
            value={editText}
            onChangeText={setEditText}
            placeholder="Edit item content"
            className="border p-2 mb-2"
          />
          <Button title="Update Item" onPress={updateItem} />
        </View>
      )}
    </View>
  );
};

export default CrudInterface;
EOF

echo "Project setup complete."
echo "IMPORTANT: Run the Supabase SQL commands from Section 1 in your Supabase dashboard to set up authentication, roles, and database schema."
```

---

By following this tutorial, you will have a fully functional mobile app framework that:

- **Integrates Supabase** for backend authentication, role assignment, and data storage,
- **Uses Expo** for the front-end with proper environment variable configuration (using `EXPO_PUBLIC_SUPABASE_URL` and `EXPO_PUBLIC_SUPABASE_ANON_KEY`),
- **Applies NativeWind** for global styling (with dark/light mode toggling),
- **Supports Storybook** for isolated UI development,
- **Includes Jest testing** for application stability, and
- **Provides a dynamic CRUD scaffolding interface.**

Happy coding, and remember to incrementally test each module and document your changes carefully while integrating with your existing system!
