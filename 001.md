# Table of Contents

- [1. Initial Setup & Configuration](#1-initial-setup--configuration)
- [2. Supabase Integration & Backend Setup](#2-supabase-integration--backend-setup)
  - [2.1 Authentication and Role Assignment](#21-authentication-and-role-assignment)
  - [2.2 Database Schema and API Service Layer](#22-database-schema-and-api-service-layer)
- [3. Building the Admin Dashboard](#3-building-the-admin-dashboard)
- [4. Implementing Social Network Features](#4-implementing-social-network-features)
  - [4.1 Posts Component](#41-posts-component)
  - [4.2 Chat Component](#42-chat-component)
- [5. Developer Experience Tools](#5-developer-experience-tools)
  - [5.1 Storybook Setup](#51-storybook-setup)
  - [5.2 Testing Setup](#52-testing-setup)
- [6. CRUD Scaffolding Interface](#6-crud-scaffolding-interface)

---

## 1. Initial Setup & Configuration

Start by running the following commands to initialize your project:

```bash
npx create-expo-app ScriptHammer
cd ScriptHammer
npm run reset-project
rm -rf app-example
```

Create a configuration file (e.g., `config.js`) to store global project variables such as the project name and Supabase credentials. This configuration is used throughout your app for dynamic branding and environment-specific settings.

```javascript
// config.js
export const APP_CONFIG = {
  projectName: 'ScriptHammer',
  // Replace with your actual Supabase credentials:
  supabaseUrl: 'https://your-supabase-url.supabase.co',
  supabaseAnonKey: 'your-supabase-anon-key',
};
```

---

## 2. Supabase Integration & Backend Setup

### 2.1 Authentication and Role Assignment

Create a Supabase client file to initialize the connection using your configuration. This file will be imported wherever you interact with Supabase.

```javascript
// supabaseClient.js
import { createClient } from '@supabase/supabase-js';
import { APP_CONFIG } from './config';

const supabaseUrl = APP_CONFIG.supabaseUrl;
const supabaseAnonKey = APP_CONFIG.supabaseAnonKey;

export const supabase = createClient(supabaseUrl, supabaseAnonKey);
```

To automatically assign roles during user sign-up, we use a database trigger in Supabase. Run the following SQL in your Supabase dashboard’s SQL editor. This code creates a function and trigger that inserts a role for new users—assigning “admin” to the very first user and “user” to everyone else:

```sql
-- 2.1: SQL to auto-assign user roles
create table if not exists public.user_roles (
  user_id uuid primary key,
  role text not null,
  created_at timestamp with time zone default now()
);

create or replace function public.assign_role()
returns trigger as $$
declare
  admin_count int;
begin
  select count(*) into admin_count from public.user_roles where role = 'admin';
  if admin_count = 0 then
    insert into public.user_roles(user_id, role) values (new.id, 'admin');
  else
    insert into public.user_roles(user_id, role) values (new.id, 'user');
  end if;
  return new;
end;
$$ language plpgsql;

drop trigger if exists assign_role_trigger on auth.users;
create trigger assign_role_trigger
after insert on auth.users
for each row execute function public.assign_role();
```

### 2.2 Database Schema and API Service Layer

Set up the initial tables for your posts and chats. Execute the following SQL in your Supabase SQL editor:

```sql
-- Create posts table
create table if not exists public.posts (
  id uuid primary key default gen_random_uuid(),
  user_id uuid references auth.users(id),
  content text not null,
  created_at timestamp with time zone default now()
);

-- Create chats table
create table if not exists public.chats (
  id uuid primary key default gen_random_uuid(),
  sender_id uuid references auth.users(id),
  receiver_id uuid references auth.users(id),
  message text not null,
  created_at timestamp with time zone default now()
);

-- Create table for CRUD operations
create table if not exists public.crud_items (
  id uuid primary key default gen_random_uuid(),
  content text not null,
  created_at timestamp with time zone default now()
);
```

Next, build a robust API service layer in your project with proper error handling and logging. Create an `apiService.js` file as follows:

```javascript
// apiService.js
import { supabase } from './supabaseClient';

// Posts API
export const fetchPosts = async () => {
  const { data, error } = await supabase
    .from('posts')
    .select('*')
    .order('created_at', { ascending: false });
  if (error) {
    console.error('Error fetching posts:', error);
    throw error;
  }
  return data;
};

export const createPost = async (content) => {
  const { data, error } = await supabase
    .from('posts')
    .insert([{ content }]);
  if (error) {
    console.error('Error creating post:', error);
    throw error;
  }
  return data;
};

// Chats API
export const fetchChats = async () => {
  const { data, error } = await supabase
    .from('chats')
    .select('*')
    .order('created_at');
  if (error) {
    console.error('Error fetching chats:', error);
    throw error;
  }
  return data;
};

export const createChatMessage = async (message) => {
  const { data, error } = await supabase
    .from('chats')
    .insert([{ message }]);
  if (error) {
    console.error('Error creating chat message:', error);
    throw error;
  }
  return data;
};
```

---

## 3. Building the Admin Dashboard

Develop a secure, role-protected admin dashboard. Create an `AdminDashboard.js` component that utilizes context to check the user’s role before rendering admin content.

```javascript
// AdminDashboard.js
import React, { useContext } from 'react';
import { View, Text, Button } from 'react-native';
import { UserContext } from './UserContext'; // Assume you have a context provider for user data

const AdminDashboard = () => {
  const { role } = useContext(UserContext);

  if (role !== 'admin') {
    return (
      <View className="p-4">
        <Text className="text-red-500 text-xl">Access Denied</Text>
        <Text>You do not have admin privileges.</Text>
      </View>
    );
  }

  return (
    <View className="p-4">
      <Text className="text-2xl font-bold mb-4">Admin Dashboard</Text>
      {/* Your dashboard content goes here */}
      <Button title="Refresh Data" onPress={() => { /* Refresh logic */ }} />
    </View>
  );
};

export default AdminDashboard;
```

*Reminder: Integrate this component carefully with your existing navigation and user context to ensure seamless role-based access control.*

---

## 4. Implementing Social Network Features

### 4.1 Posts Component

Create a `PostList.js` component that fetches and displays posts, and allows the user to create a new post. Notice the use of NativeWind classes for styling.

```javascript
// PostList.js
import React, { useEffect, useState } from 'react';
import { View, Text, FlatList, Button } from 'react-native';
import { fetchPosts, createPost } from './apiService';

const PostList = () => {
  const [posts, setPosts] = useState([]);

  const loadPosts = async () => {
    try {
      const data = await fetchPosts();
      setPosts(data);
    } catch (error) {
      console.error('Error loading posts:', error);
    }
  };

  useEffect(() => {
    loadPosts();
  }, []);

  return (
    <View className="p-4">
      <Text className="text-2xl font-bold mb-4">Posts</Text>
      <FlatList
        data={posts}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <View className="mb-2 p-2 border rounded">
            <Text>{item.content}</Text>
          </View>
        )}
      />
      <Button title="New Post" onPress={() => createPost("Sample post content").then(loadPosts)} />
    </View>
  );
};

export default PostList;
```

### 4.2 Chat Component

Develop a `ChatComponent.js` that handles real-time updates using Supabase subscriptions.

```javascript
// ChatComponent.js
import React, { useEffect, useState } from 'react';
import { View, Text, FlatList, TextInput, Button } from 'react-native';
import { supabase } from './supabaseClient';
import { createChatMessage, fetchChats } from './apiService';

const ChatComponent = () => {
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState('');

  const loadMessages = async () => {
    try {
      const data = await fetchChats();
      setMessages(data);
    } catch (error) {
      console.error('Error loading messages:', error);
    }
  };

  const sendMessage = async () => {
    if (!newMessage) return;
    try {
      await createChatMessage(newMessage);
      setNewMessage('');
      // loadMessages will be triggered by subscription, but you can also force refresh:
      // loadMessages();
    } catch (error) {
      console.error('Error sending message:', error);
    }
  };

  useEffect(() => {
    loadMessages();
    const subscription = supabase
      .from('chats')
      .on('INSERT', payload => {
        setMessages((prev) => [...prev, payload.new]);
      })
      .subscribe();

    return () => {
      supabase.removeSubscription(subscription);
    };
  }, []);

  return (
    <View className="p-4">
      <Text className="text-2xl font-bold mb-4">Chat</Text>
      <FlatList
        data={messages}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <View className="mb-2 p-2 border rounded">
            <Text>{item.message}</Text>
          </View>
        )}
      />
      <TextInput 
        value={newMessage}
        onChangeText={setNewMessage}
        placeholder="Type your message..."
        className="border p-2 mb-2"
      />
      <Button title="Send" onPress={sendMessage} />
    </View>
  );
};

export default ChatComponent;
```

---

## 5. Developer Experience Tools

### 5.1 Storybook Setup

Configure Storybook for developing and testing your UI components in isolation. Create a `.storybook/main.js` file:

```javascript
// .storybook/main.js
module.exports = {
  stories: ['../components/**/*.stories.@(js|jsx|ts|tsx)'],
  addons: [
    '@storybook/addon-links',
    '@storybook/addon-essentials',
  ],
};
```

Then, add an initial story for a reusable component (e.g., a Button component):

```javascript
// components/Button.stories.js
import React from 'react';
import { Button } from 'react-native';
import { storiesOf } from '@storybook/react-native';

storiesOf('Button', module)
  .add('default', () => (
    <Button title="Click Me" onPress={() => {}} />
  ));
```

### 5.2 Testing Setup

Set up Jest for testing your critical application paths. Create a test file (`App.test.js`) to capture a snapshot of your main App component:

```javascript
// App.test.js
import React from 'react';
import renderer from 'react-test-renderer';
import App from './App';

it('renders correctly', () => {
  const tree = renderer.create(<App />).toJSON();
  expect(tree).toMatchSnapshot();
});
```

Also, add a Jest configuration file (`jest.config.js`):

```javascript
// jest.config.js
module.exports = {
  preset: 'jest-expo',
  transform: {
    '^.+\\.js$': '<rootDir>/node_modules/react-native/jest/preprocessor.js',
  },
  setupFiles: ['./jest.setup.js'],
};
```

And a simple Jest setup file (`jest.setup.js`):

```javascript
// jest.setup.js
import 'react-native-gesture-handler/jestSetup';
```

---

## 6. CRUD Scaffolding Interface

Create a dynamic CRUD interface component that guides users through creating custom operations. This component interacts with a dedicated Supabase table (`crud_items`). The complete file below is fully functional:

```javascript
// CrudInterface.js
import React, { useState, useEffect } from 'react';
import { View, Text, TextInput, Button, FlatList } from 'react-native';
import { supabase } from './supabaseClient';

const CrudInterface = () => {
  const [items, setItems] = useState([]);
  const [newItem, setNewItem] = useState('');
  const [editItemId, setEditItemId] = useState(null);
  const [editText, setEditText] = useState('');

  const fetchItems = async () => {
    const { data, error } = await supabase.from('crud_items').select('*').order('created_at', { ascending: false });
    if (error) {
      console.error('Error fetching items:', error);
    } else {
      setItems(data);
    }
  };

  const createItem = async () => {
    if (!newItem) return;
    const { data, error } = await supabase.from('crud_items').insert([{ content: newItem }]);
    if (error) {
      console.error('Error creating item:', error);
    } else {
      setNewItem('');
      fetchItems();
    }
  };

  const updateItem = async () => {
    if (!editText || !editItemId) return;
    const { data, error } = await supabase.from('crud_items').update({ content: editText }).eq('id', editItemId);
    if (error) {
      console.error('Error updating item:', error);
    } else {
      setEditItemId(null);
      setEditText('');
      fetchItems();
    }
  };

  const deleteItem = async (id) => {
    const { data, error } = await supabase.from('crud_items').delete().eq('id', id);
    if (error) {
      console.error('Error deleting item:', error);
    } else {
      fetchItems();
    }
  };

  useEffect(() => {
    fetchItems();
  }, []);

  return (
    <View className="p-4">
      <Text className="text-2xl font-bold mb-4">CRUD Scaffolding Interface</Text>
      <TextInput 
        value={newItem}
        onChangeText={setNewItem}
        placeholder="New item content"
        className="border p-2 mb-2"
      />
      <Button title="Add Item" onPress={createItem} />
      <FlatList
        data={items}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <View className="my-2 p-2 border rounded">
            <Text>{item.content}</Text>
            <Button title="Edit" onPress={() => { setEditItemId(item.id); setEditText(item.content); }} />
            <Button title="Delete" onPress={() => deleteItem(item.id)} />
          </View>
        )}
      />
      {editItemId && (
        <View className="mt-4">
          <Text>Edit Item</Text>
          <TextInput 
            value={editText}
            onChangeText={setEditText}
            placeholder="Edit item content"
            className="border p-2 mb-2"
          />
          <Button title="Update Item" onPress={updateItem} />
        </View>
      )}
    </View>
  );
};

export default CrudInterface;
```

*Reminder: Ensure that you integrate this CRUD interface with your existing navigation and styling systems, and always back up your current codebase before making major changes.*

---

By following this tutorial, you create a robust, maintainable mobile app framework that leverages best practices in code quality and integration. Each step is designed to integrate cleanly with your existing system while ensuring that future enhancements can be made with confidence and minimal disruption.

Happy coding, and remember to incrementally test each module as you integrate it into your larger project!
