Great! I'll generate a fully fleshed-out implementation tutorial covering every aspect of the framework, including authentication, CLI module generation, Supabase integration, theming, role-based admin panels, and automation scripts. This tutorial will be structured as a Markdown document, making it easy for you to copy and save as a README file.

Iâ€™ll let you know once the tutorial is ready! ðŸš€

# Expo Framework Tutorial: CLI Module Builder, Supabase Auth, Steampunk UI & More

This tutorial walks you through building a complete Expo-based framework from scratch. We'll create a **CLI-based module generator**, integrate **Supabase authentication** (with OAuth), set up a **role-based admin panel**, design a **steampunk-themed UI** with NativeWind, and add **social networking features** like posts, comments, and real-time updates. Weâ€™ll also cover global architecture, Supabase security (RLS), best practices, and include an automation script for scaffolding the project. 

**Table of Contents**  
1. [CLI-Based Module Builder](#cli-based-module-builder)  
2. [Authentication with Supabase](#authentication-with-supabase)  
3. [Role-Based Admin Panel & User Role Management](#role-based-admin-panel--user-role-management)  
4. [Steampunk-Themed UI with NativeWind](#steampunk-themed-ui-with-nativewind)  
5. [Social Networking Features](#social-networking-features)  
6. [Global Architecture and Provider Setup](#global-architecture-and-provider-setup)  
7. [Supabase Data Management & Security](#supabase-data-management--security)  
8. [Documentation & Best Practices](#documentation--best-practices)  
9. [Automation Scripts for Project Setup](#automation-scripts-for-project-setup)  

## CLI-Based Module Builder

In this section, we'll create a Command-Line Interface (CLI) tool that can generate entire modules (list, detail, form screens) from a configuration file. The config will be provided in XAML format, defining data models, fields, and screen types. Our CLI will parse this XAML and output TypeScript/TSX files in the proper Expo Router directories, wiring them into navigation automatically.

### 1.1 Overview of the Module Builder

**Goal:** Automate creation of screens based on a schema. Given a XAML config describing a data model (like a table schema) and the screens needed (list, detail, form), the CLI will produce: 
- A list screen component (shows a list of records).  
- A detail screen component (shows record details).  
- A form screen component (for creating/editing the record).  

The files will be placed in `app/(main)/...` with appropriate naming. We leverage **Expo Router**â€™s file-based routing where any file in `app/` becomes a route automatically By generating files in the `app` directory, we integrate new modules into navigation with zero config.

**Expo Router Recap:** In an Expo Router app, the folder structure under `app/` defines the navigation routes. For example, `app/products/index.tsx` becomes the `/products` list route, and `app/products/[id].tsx` can represent a `/products/:id` detail route We will follow these conventions:
- **List Screen:** `app/(main)/YourModuleName/index.tsx` (route: `/YourModuleName`)  
- **Detail Screen:** `app/(main)/YourModuleName/[id].tsx` (dynamic route for item details)  
- **Form Screen:** `app/(main)/YourModuleName/new.tsx` for adding new items (or optionally `edit.tsx` or similar for editing).

By placing these in an `(main)` folder, we group them logically but not alter the URL (folder names in parentheses are **routing groups** that do not appear in the path) We will ensure the CLI uses consistent naming and file placement.

### 1.2 Defining the XAML Configuration

First, decide the XAML schema format. For example, a simple XAML could look like:

```xml
<!-- module-config.xaml -->
<Module name="Product">
  <Model table="products">
    <Field name="name" type="string" />
    <Field name="price" type="number" />
    <Field name="in_stock" type="boolean" />
  </Model>
  <Screens>
    <List title="Products" />
    <Detail title="Product Details" />
    <Form title="Add Product" />
  </Screens>
</Module>
```

Here, **Module** has a name and defines a **Model** (with table name and fields) and desired **Screens**. We keep it flexible â€“ you might extend it with validations, relations, etc., but we'll handle basic fields.

### 1.3 Parsing XAML in the CLI

We can create a Node.js script (using TypeScript or plain JS) to parse this XML. There are libraries like `xml2js` or `fast-xml-parser` to help convert XML to JSON.

**Steps for the CLI script**:
1. **Read the XAML file** â€“ e.g., take a file path argument.
2. **Parse XML to JS Object** â€“ using a library. For example, with `xml2js`:
   ```bash
   npm install xml2js fs-extra
   ```
   Then in our script:
   ```ts
   import { readFileSync, writeFileSync } from 'fs';
   import { parseStringPromise } from 'xml2js';

   const xml = readFileSync(configPath, 'utf-8');
   const config = await parseStringPromise(xml);
   ```
3. **Extract module info** â€“ e.g., `config.Module.$.name` for module name, fields, etc. The exact structure depends on the parser's output.
4. **Generate file contents** â€“ Use template strings or a small template engine. For each screen type (List, Detail, Form), create a string of the TSX component code.
5. **Write files** â€“ Save to `app/(main)/ModuleName/ScreenName.tsx`.

Let's outline a simplified version of such a script (we'll call it `generate-module.mjs` for illustration):

```ts
#!/usr/bin/env node
import fs from 'fs';
import { parseStringPromise } from 'xml2js';

const [,, configPath] = process.argv;
if (!configPath) {
  console.error("Usage: generate-module <config-file.xaml>");
  process.exit(1);
}
const xml = fs.readFileSync(configPath, 'utf-8');
const config = await parseStringPromise(xml);

// Extract module name and details
const moduleName = config.Module.$.name; // e.g., "Product"
const tableName = config.Module.Model[0].$.table; // e.g., "products"
const fields = config.Module.Model[0].Field.map(f => ({ 
    name: f.$.name, type: f.$.type 
}));

// Prepare directory
const baseDir = `app/(main)/${moduleName.toLowerCase()}s`; 
fs.mkdirSync(baseDir, { recursive: true });

// Generate List Screen
const listScreen = 
`import { useRouter, Link } from 'expo-router';
import { Text, View, TouchableOpacity } from 'react-native';
import { useEffect, useState } from 'react';
import { supabase } from '../../utils/supabase'; // Supabase client

export default function ${moduleName}List() {
  const [items, setItems] = useState([]);
  useEffect(() => {
    // Fetch items from Supabase
    supabase.from('${tableName}')
      .select('*')
      .then(({ data, error }) => {
        if (!error) setItems(data);
      });
  }, []);

  return (
    <View className="flex-1 p-4">
      {items.map(item => (
        <Link 
          href="/${moduleName.toLowerCase()}s/${'${item.id}'}" 
          asChild key={item.id}>
          <TouchableOpacity className="p-2 border-b border-gray-300">
            <Text>{item.name}</Text>
          </TouchableOpacity>
        </Link>
      ))}
      <Link href="/${moduleName.toLowerCase()}s/new" asChild>
        <TouchableOpacity className="mt-4 p-2 bg-blue-600 rounded">
          <Text className="text-white text-center">Add ${moduleName}</Text>
        </TouchableOpacity>
      </Link>
    </View>
  );
}`;
fs.writeFileSync(`${baseDir}/index.tsx`, listScreen);

// Similar generation for Detail and Form screens...
```

In the List screen template above, we:
- Use the Supabase client to fetch all records from the specified table (e.g., `products`).
- Render each item as a link to the detail route using Expo Routerâ€™s `<Link>` component.
- Provide a button/link to the "new" form screen.

We would generate **Detail Screen** similarly, e.g., `app/(main)/products/[id].tsx`, using a dynamic route for item ID:
```ts
export default function ProductDetail() {
  const { id } = useLocalSearchParams<{ id: string }>(); // retrieve 'id' param
  const [item, setItem] = useState(null);
  useEffect(() => {
    supabase.from('products').select('*').eq('id', id).single()
      .then(({ data }) => setItem(data));
  }, [id]);
  // ...render item details...
}
```
Here we use `useLocalSearchParams` from Expo Router to get the route param ([Using URL parameters - Expo Documentation](https://docs.expo.dev/router/reference/url-parameters/#:~:text=In%20nested%20apps%2C%20you%27ll%20often,hooks%20for%20accessing%20URL%20parameters))  We then fetch one item by ID. (In a real scenario, weâ€™d handle loading and error states too.)

The **Form Screen** (`new.tsx`) would include a form (using TextInput, etc.) to create a new record. It might use Supabase `insert()` to add the item, then navigate back to the list. For brevity:
```ts
export default function ProductForm() {
  const router = useRouter();
  const [form, setForm] = useState({ name: '', price: '' /* etc */});
  const handleSubmit = async () => {
    const { error } = await supabase.from('products').insert(form);
    if (!error) router.replace('/products'); // go back to list
  };
  return (
    <View className="p-4">
      {/* TextInput fields bound to form state for each field */}
      <TouchableOpacity onPress={handleSubmit}>
        <Text>Save</Text>
      </TouchableOpacity>
    </View>
  );
}
```
*(Add proper TextInput components and form validation as needed.)*

After generating all screens, the CLI ensures they are in place. Because we followed the naming convention and directory structure, **Expo Router will automatically pick up these routes**â€”no manual linking needed. The list screen becomes accessible at `/products`, detail at `/products/[id]`, etc. You can confirm the routes by running the app; Expo Router scans `app/` on startup to register routes

**Integrating with Navigation:** If you plan nested navigators (e.g., a tab or stack), ensure to include a `_layout.tsx` if needed. For example, if all generated modules live under `(main)`, you could have `app/(main)/_layout.tsx` rendering a `<Stack>` navigator for those screens. But if you already have a root stack (see section 6), it may not be necessary. Expo Routerâ€™s default root layout can handle it, or you can group screens logically (e.g., group all module screens under a common layout if needed for shared UI like headers).

**Summary:** The CLI tool greatly speeds up development by generating boilerplate for CRUD screens. It sets up:
- File-based routes (aligning with Expo Routerâ€™s conventions.
- Basic data fetching using Supabase (so you have a starting point to refine).
- Integration with navigation (via the file placement and `<Link>` usage).
- Consistent styling references (we added some Tailwind classes like `p-4`, which we'll configure later).

**Next steps:** You can enhance the generator to include custom field types, relations (e.g., dropdowns for foreign keys), or form validation. But the foundation is set. Now, let's move on to setting up authentication since many features (like restricting access and linking data to users) require a user system.

## Authentication with Supabase

Now we will implement full user authentication using Supabase Auth in our Expo app. This includes email/password sign-up & login, as well as OAuth sign-in with Google and Apple. Weâ€™ll handle session persistence (so users stay logged in) and deep linking for OAuth redirects. Supabase provides a powerful auth system that we can integrate with minimal effort using the supabase-js SDK

### 2.1 Setting Up Supabase in Expo

**Install Supabase SDK:** If not already installed, add supabase and related packages:
```bash
npx expo install @supabase/supabase-js @react-native-async-storage/async-storage react-native-url-polyfill
```
This will install the Supabase JS client and AsyncStorage. We also include `react-native-url-polyfill` which fixes URL handling in React Native (Supabase recommends this for Auth).

**Initialize the client:** Create a file `utils/supabase.ts`:
```ts
import 'react-native-url-polyfill/auto';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = '<YOUR_SUPABASE_URL>';        // e.g., https://xyzcompany.supabase.co
const supabaseAnonKey = '<YOUR_SUPABASE_ANON_KEY>'; // from Supabase project settings

export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    storage: AsyncStorage,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: false, // prevents parsing browser URL for tokens
  },
});
```
This follows Supabaseâ€™s Expo setup guidelines We configure:
- **AsyncStorage** for storing the JWT auth token (so the session persists across app restarts).
- `autoRefreshToken: true` to automatically refresh the JWT when it's about to expire.
- `persistSession: true` to load/save session from storage.
- `detectSessionInUrl: false` because in a mobile app we won't use URL callbacks in the web environment (we'll handle deep links manually).

> **Note:** The `supabaseAnonKey` is safe to expose in the client *only if* Row Level Security is enabled on your tables By default, Supabase enables RLS on new tables so as long as you create policies appropriately, using the anon key in the app is secure.

Now we can import and use `supabase` in any component or utility to call Supabase APIs.

### 2.2 User Sign-Up and Login (Email/Password)

We will create screens for **Sign Up** and **Sign In** (and possibly a combined or toggle screen). For example, `app/sign-in.tsx` for login, and `app/sign-up.tsx` for registration. These will be accessible without auth (we will protect other routes later).

**Sign Up screen example (`app/sign-up.tsx`):**
```tsx
import { supabase } from '../utils/supabase';
import { useState } from 'react';
import { View, TextInput, Text, TouchableOpacity } from 'react-native';
import { Link, useRouter } from 'expo-router';

export default function SignUpScreen() {
  const router = useRouter();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState<string | null>(null);

  const handleSignUp = async () => {
    setError(null);
    const { error: signUpError } = await supabase.auth.signUp({ email, password });
    if (signUpError) {
      setError(signUpError.message);
    } else {
      // Optionally, you can require email verification. If not, user is now signed in.
      router.replace('/(app)'); // navigate to main app section
    }
  };

  return (
    <View className="flex-1 justify-center p-4 bg-[#1c1c1c]">
      <Text className="text-2xl text-center text-white mb-4">Create Account</Text>
      {error && <Text className="text-red-500 mb-2">{error}</Text>}
      <TextInput
        placeholder="Email" autoCapitalize="none"
        className="bg-white text-black mb-2 p-2 rounded"
        value={email} onChangeText={setEmail}
      />
      <TextInput
        placeholder="Password" secureTextEntry
        className="bg-white text-black mb-4 p-2 rounded"
        value={password} onChangeText={setPassword}
      />
      <TouchableOpacity onPress={handleSignUp} className="bg-yellow-700 p-2 rounded">
        <Text className="text-white text-center">Sign Up</Text>
      </TouchableOpacity>
      <Text className="text-center text-gray-300 mt-4">
        Have an account? <Link href="/sign-in"><Text className="text-blue-400">Sign In</Text></Link>
      </Text>
    </View>
  );
}
```
In this **SignUpScreen**: 
- We collect email & password, call `supabase.auth.signUp({ email, password })`.
- If no error, we redirect the user to the main app (assuming theyâ€™re logged in immediately; if email confirmation is enabled in Supabase, you might need to inform the user to check their email).
- We used some Tailwind classes (via NativeWind) for styling (we'll configure those in section 4). The style aims for a steampunk vibe (dark background, etc. - details on theme later).

**Sign In screen** would be similar but call `supabase.auth.signInWithPassword({ email, password })` and handle errors accordingly. After sign-in, youâ€™d navigate to the app.

**Sign Out**: Weâ€™ll likely put a sign-out button in a user menu or settings. It simply calls `supabase.auth.signOut()` and then clears state (context) and navigates to sign-in screen.

### 2.3 OAuth with Google and Apple

Supabase Auth supports Google and Apple OAuth out-of-the-box. We will use **Expo AuthSession** to handle the OAuth flow in React Native, as recommended by Supabase This involves:
- Configuring the provider in Supabase (get client IDs and secrets, set redirect URL).
- Using `startAsync` from `expo-auth-session` to open the providerâ€™s login page, then capturing the redirect with the auth code or tokens.
- Exchanging that with Supabase to establish a session.

**Configure Supabase OAuth Providers:**
- In Supabase Dashboard, enable Google and Apple under **Authentication > Providers**. 
  - For Google: provide the OAuth Client ID and secret from Google Cloud and add **Redirect URL**: `YOUR_SUPABASE_URL/auth/v1/callback` (Supabase docs detail this.
  - For Apple: you need to provide your Service ID, key, etc., and also use the callback URL.
- For mobile deep linking, also add a custom scheme URL as an authorized redirect URI: e.g., `com.myapp://auth/callback`. We will use a scheme for our Expo app to handle the callback.

**Set up Expo deep linking:** In `app.json`, add:
```json
{
  "expo": {
    "scheme": "com.myapp", 
    "ios": {
      "bundleIdentifier": "com.mycompany.myapp"
    },
    "android": {
      "package": "com.mycompany.myapp"
    },
    ...
  }
}
```
The **scheme** (and matching bundle ID/package) will be used by AuthSession to intercept the OAuth redirect ([Install Expo Router - Expo Documentation](https://docs.expo.dev/router/installation/#:~:text=Add%20a%20deep%20linking%20,in%20your%20app%20config))  For development in Expo Go, AuthSession uses an intermediate "expo.dev/@" redirect, but it abstracts it away. Just ensure the scheme is set for production.

**Implementing Google Sign-In:**
Install AuthSession:
```bash
npx expo install expo-auth-session
```
Now create a helper, say `utils/auth.ts`:
```ts
import { makeRedirectUri, startAsync } from 'expo-auth-session';
import { supabase } from './supabase';

export async function signInWithGoogle() {
  // Construct redirect URI (using the scheme configured)
  const redirectUrl = makeRedirectUri({
    path: '/auth/callback',   // This path should match what you set in Supabase redirect URLs
  });
  const authUrl = `${supabase.supabaseUrl}/auth/v1/authorize?provider=google&redirect_to=${redirectUrl}`;
  
  const result = await startAsync({ authUrl, returnUrl: redirectUrl });
  if (result.type === 'success' && result.params.access_token) {
    // Exchange the token for a Supabase session
    await supabase.auth.setSession({
      access_token: result.params.access_token,
      refresh_token: result.params.refresh_token,
    });
    return true;
  } else {
    // Handle cancellations or errors
    return false;
  }
}
```
This follows the approach from a community example
- We use Supabaseâ€™s built-in auth endpoint: `/auth/v1/authorize?provider=google` with a redirect.
- `startAsync` opens the webview for Google login and waits for redirect.
- On success, Supabase includes `access_token` and `refresh_token` in the callback. We call `supabase.auth.setSession()` with those tokens to finalize login This populates Supabase's auth state (and AsyncStorage) with the new session.

For Apple, the process is similar:
```ts
export async function signInWithApple() {
  const redirectUrl = makeRedirectUri({ path: '/auth/callback' });
  const authUrl = `${supabase.supabaseUrl}/auth/v1/authorize?provider=apple&redirect_to=${redirectUrl}`;
  const result = await startAsync({ authUrl, returnUrl: redirectUrl });
  if (result.type === 'success' && result.params.access_token) {
    await supabase.auth.setSession({
      access_token: result.params.access_token,
      refresh_token: result.params.refresh_token,
    });
    return true;
  }
  return false;
}
```
*(Apple might require additional configuration in Apple Developer portal with the redirect scheme; ensure those steps are done per Supabase docs.)*

Now, integrate these functions in the Sign-In screen UI:
```tsx
// Inside SignInScreen component render:
<TouchableOpacity onPress={signInWithGoogle} className="bg-white p-2 rounded flex flex-row items-center justify-center">
  <Image source={require('../assets/google-logo.png')} style={{ width: 20, height: 20, marginRight: 8 }} />
  <Text>Sign in with Google</Text>
</TouchableOpacity>
{/* Similar button for Apple, using Apple logo and signInWithApple */}
```
This provides buttons for OAuth. When pressed, it triggers the web flow and logs the user in. On iOS, a browser pop-up will appear for Google; for Apple, it might use the native prompt if configured correctly.

**Deep Link Handling:** With the above approach, `expo-auth-session` should handle the deep link automatically, thanks to `makeRedirectUri` using our scheme. When the app receives the redirect (e.g., `com.myapp://auth/callback#access_token=...`), AuthSession parses it and returns it as `result.params`. We set `detectSessionInUrl: false` earlier because we manually handle it instead of letting the Supabase client try to parse a web URL.

### 2.4 Session Persistence and Auto-Refresh

We already set `persistSession: true` and `autoRefreshToken: true` in the client config This means:
- When the app restarts, Supabase will load the saved session (if any) from AsyncStorage automatically.
- Supabase will also manage refreshing the JWT using the refresh token behind the scenes, so long as the app is running. This keeps the user logged in without interruptions.

To leverage this, when our app mounts, we should check if a session exists and update our state (or context) accordingly:
```ts
// Pseudo-code for initial auth state check (perhaps in our AuthContext provider)
const { data: { session } } = await supabase.auth.getSession();
if (session) {
  setUserSession(session); // update context or state with logged-in user
}
```
Also, we can subscribe to auth events:
```ts
supabase.auth.onAuthStateChange((_event, session) => {
  setUserSession(session);
});
```
This ensures our app knows when the user logs in or out (including via OAuth or token refresh).

### 2.5 Secure Credential Storage

We keep the Supabase URL and anon key outside of source code when possible:
- In development, you might use a `.env` file and load it in `supabase.ts` (with something like `process.env.SUPABASE_URL` if using expo's dotenv support or a library). 
- In production with EAS (Expo Application Services), use **Encrypted Secrets** or set these in your build config. However, as noted, the anon key is not highly sensitive (it cannot bypass RLS.

For storing user credentials (like maybe an OAuth refresh token manually), AsyncStorage is fine as configured. If you have extra sensitive info, consider using `expo-secure-store` which provides encrypted storage. Supabase's integration, however, uses AsyncStorage by default for convenience and it's generally secure for storing JWTs on device.

That covers authentication. We have:
- Email/password sign-up & sign-in with error handling.
- Google/Apple OAuth integrated with deep linking
- Persistent sessions with auto-refresh of tokens.
- A sign-out method to clear session.

Next, we will set up role-based access control and an admin panel to manage user roles.

## Role-Based Admin Panel & User Role Management

Now that users can authenticate, we want to establish **roles** (e.g., regular user vs admin) and restrict certain parts of the app to admins. We also want an admin dashboard where admins can manage the app (for example, view all users, promote others to admin, etc.). 

We will implement a simple Role-Based Access Control (RBAC) system:
- **Role assignment:** The first user to register becomes an "admin" by default. Other users are "user" role unless an admin upgrades them.
- We'll maintain roles in the database (for persistence and security).
- **React Context for auth**: We'll create an AuthContext to hold the current user's session and role, so components can easily check `isAdmin` or `isAuthenticated`.
- **Protected routes**: Use Expo Router grouping to guard routes (e.g., only logged-in users can access `(app)` group, and only admins can access admin pages).

### 3.1 Extending the User Model with Roles

We need to decide how to store roles. Options:
- Supabase **Auth users** have a `role` property (`authenticated` or `service_role` internally, but not custom roles).
- We can use the public `profiles` table (often created in Supabase quickstart) to store additional info for each user, including a `role` field.
  
Let's create a table `profiles` with at least: `id (UUID primary key)`, `user_id (UUID ref auth.users)`, `role (text)`. Alternatively, use the `id` as user_id itself if 1-1. (Supabase quick start often uses id=user_id and RLS to link to auth.uid()).

**Assign first user as admin:** We can do this logic on the client after sign-up:
```ts
// After signUp (if email confirmation not required):
if (!signUpError) {
  // Check how many users exist (this requires an RPC or open rule to count users)
  const { data: users, error } = await supabase.auth.admin.listUsers(); // This requires service_role, which we cannot use on client
  // Instead, maintain a 'firstUser' flag via some other means. Simpler: have a boolean in profiles "is_admin".
}
```
A simpler approach: Use Supabase **Postgres function/trigger**. For example, create a trigger on the `users` table (or on `profiles` insert) to mark the first inserted user as admin. However, doing that via SQL is advanced for this tutorial's scope.

Instead, we'll do it at app-level:
- After a user signs up and logs in, call a function to create their profile in the database with role. If there are no existing admins, set role = 'admin', else 'user'.
- How to check if an admin exists? One way: have a column or a separate table to track roles. Or simply query `profiles` table for any `role = 'admin'`. With RLS, a normal user might not be allowed to query all profiles. We might allow a function to check count.

For simplicity, let's assume no users means none in `profiles` yet:
```ts
async function createProfileForNewUser(userId: string, email: string) {
  // Check if any admin exists
  const { data: admins, error } = await supabase.from('profiles')
    .select('id').eq('role', 'admin');
  let role = 'user';
  if (!error && admins.length === 0) {
    role = 'admin';
  }
  await supabase.from('profiles').insert({ user_id: userId, email, role });
}
```
We would call this right after sign-up (or on first sign-in if profile not created). This requires that we allow inserting into profiles (maybe an RLS rule that a user can insert their own profile).

Alternatively, the app could ship with a default admin invited out-of-band, but let's stick to auto-admin for first user.

Now our AuthContext can load the profile including role.

### 3.2 Creating an Auth & Role Context

Using React Context will allow any component to access `user`, `role`, `signIn`, `signOut` without prop drilling. We will create `AuthContext.tsx` provider.

**AuthContext Implementation:**
```tsx
// utils/AuthContext.tsx (or in app/_layout, as needed)
import { createContext, useContext, useState, useEffect } from 'react';
import { supabase } from './supabase';

interface AuthContextType {
  session: Session | null;
  profile: { role: string } | null;
  signOut: () => void;
}

// create context
const AuthContext = createContext<AuthContextType | undefined>(undefined);

// Provider component
export function AuthProvider({ children }) {
  const [session, setSession] = useState<Session|null>(null);
  const [profile, setProfile] = useState<{ role: string } | null>(null);

  useEffect(() => {
    // Check initial session and profile
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session);
      if (session) fetchProfile(session);
    });
    // Listen for auth state changes (login/logout)
    const { data: listener } = supabase.auth.onAuthStateChange((event, session) => {
      setSession(session);
      if (session) {
        fetchProfile(session);
      } else {
        setProfile(null);
      }
    });
    return () => listener.subscription.unsubscribe();
  }, []);

  const fetchProfile = async (session: Session) => {
    const { data, error } = await supabase.from('profiles')
      .select('role')
      .eq('user_id', session.user.id)
      .single();
    if (!error && data) {
      setProfile({ role: data.role });
    }
  };

  const signOut = async () => {
    await supabase.auth.signOut();
    // supabase.auth.onAuthStateChange listener will handle clearing session
  };

  const value = { session, profile, signOut };
  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

// Hook for easy usage
export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error("useAuth must be used within AuthProvider");
  }
  return context;
}
```
Here:
- We track `session` (Supabase session object, which includes user info and tokens) and `profile` (our app-specific data including role).
- On init and on any auth change, we fetch the user's profile to get their role.
- `signOut` calls Supabase and the listener resets state.

We will wrap our app's navigation in `<AuthProvider>` so that all screens can use `useAuth()` to get the current user or role.

### 3.3 Protecting Routes with Expo Router Groups

Expo Router allows organizing routes into groups that we can conditionally render or redirect from, often in a `_layout.tsx` file ([Authentication in Expo Router - Expo Documentation](https://docs.expo.dev/router/reference/authentication/#:~:text=Using%20React%20Context%20and%20Route,Groups))  ([Authentication in Expo Router - Expo Documentation](https://docs.expo.dev/router/reference/authentication/#:~:text=%60sign))  

We'll use two groups:
- `(app)` â€“ for all authenticated user screens (the main app).
- `admin` (as a nested route or group) â€“ for admin-only screens.

**Authenticated Group:** In `app/(app)/_layout.tsx`:
```tsx
import { Stack, Redirect } from 'expo-router';
import { useAuth } from '../../utils/AuthContext';

export default function AppLayout() {
  const { session, profile } = useAuth();
  // If not logged in, redirect to sign-in
  if (!session) {
    return <Redirect href="/sign-in" />;
  }
  return <Stack />;
}
```
This ensures any route under `(app)` is only accessible when `session` is non-null (user is logged in) ([Authentication in Expo Router - Expo Documentation](https://docs.expo.dev/router/reference/authentication/#:~:text=))  We use `<Redirect>` from expo-router to send them to the sign-in page if not authed.

We also have access to `profile.role` here. We might not need it for general app routes, but could use it in admin.

**Admin Group:** We can set up the admin section under the `(app)` group (since admin must also be authenticated). Let's create `app/(app)/admin/_layout.tsx`:
```tsx
import { Stack, Redirect } from 'expo-router';
import { useAuth } from '../../../utils/AuthContext';

export default function AdminLayout() {
  const { profile } = useAuth();
  // If user is not admin, redirect or show not-authorized
  if (profile?.role !== 'admin') {
    return <Redirect href="/"(app) />;  // send to main app home if not admin
  }
  return <Stack />;
}
```
Now, any screen inside `app/(app)/admin/` will first go through this layout. If the userâ€™s role isnâ€™t 'admin', we prevent access. (We could alternatively show a "Not Authorized" message instead of redirect.)

So, structure wise:
```
app
 â”œ _layout.tsx        (Root layout with providers)
 â”œ sign-in.tsx
 â”œ sign-up.tsx
 â”œ (app)
 â”‚   â”œ _layout.tsx    (Auth-protected layout)
 â”‚   â”œ index.tsx      (e.g., main feed or home screen, requires login)
 â”‚   â”œ profile.tsx    (user profile screen)
 â”‚   â”œ ... other user screens ...
 â”‚   â”” admin
 â”‚       â”œ _layout.tsx  (Admin-protected layout)
 â”‚       â”œ index.tsx    (Admin dashboard home)
 â”‚       â”” users.tsx    (Example admin screen: manage users)
```
*(The `index.tsx` inside (app) could be the main logged-in landing page, like a feed or dashboard for normal users.)*

### 3.4 Building the Admin Panel

Now create some admin pages. For example, an **Admin Dashboard** (`app/(app)/admin/index.tsx`):
```tsx
import { View, Text, TouchableOpacity } from 'react-native';
import { Link } from 'expo-router';

export default function AdminDashboard() {
  return (
    <View className="flex-1 p-4">
      <Text className="text-2xl font-bold mb-4">Admin Dashboard</Text>
      <Link href="/admin/users" asChild>
        <TouchableOpacity className="bg-gray-700 p-3 mb-2 rounded">
          <Text className="text-white">Manage Users</Text>
        </TouchableOpacity>
      </Link>
      {/* Add links or buttons for other admin tasks */}
    </View>
  );
}
```
And a **Manage Users** screen (`app/(app)/admin/users.tsx`) where an admin can see all users and change roles:
```tsx
import { useEffect, useState } from 'react';
import { View, Text, TouchableOpacity, FlatList } from 'react-native';
import { supabase } from '../../../utils/supabase';

interface UserProfile { id: string; email: string; role: string; }

export default function ManageUsers() {
  const [users, setUsers] = useState<UserProfile[]>([]);
  useEffect(() => {
    // Fetch all profiles (this assumes RLS allows admin to see all)
    supabase.from('profiles').select('user_id, email, role')
      .then(({ data, error }) => {
        if (!error && data) setUsers(data);
      });
  }, []);

  const promoteToAdmin = async (userId: string) => {
    await supabase.from('profiles').update({ role: 'admin' }).eq('user_id', userId);
    setUsers(users.map(u => u.user_id === userId ? { ...u, role: 'admin' } : u));
  };

  return (
    <View className="flex-1 p-4">
      <Text className="text-xl font-bold mb-3">User Accounts</Text>
      <FlatList
        data={users}
        keyExtractor={(item) => item.user_id}
        renderItem={({ item }) => (
          <View className="flex-row justify-between py-2 border-b border-gray-300">
            <Text>{item.email} ({item.role})</Text>
            {item.role !== 'admin' && (
              <TouchableOpacity onPress={() => promoteToAdmin(item.user_id)}>
                <Text className="text-blue-500">Make Admin</Text>
              </TouchableOpacity>
            )}
          </View>
        )}
      />
    </View>
  );
}
```
Here:
- We retrieve all user profiles. **Security:** We must set a Supabase RLS policy on `profiles` to allow admins to select all (and update roles), while normal users can only select/update their own profile. For example, a policy: `CREATE POLICY "Admins can manage profiles" ON profiles FOR ALL USING (EXISTS (SELECT 1 FROM profiles p2 WHERE p2.user_id = auth.uid() AND p2.role = 'admin'));` â€“ this is a bit advanced, but basically check if current user is admin.
- The UI lists each user with their email and role. If not admin, an admin can tap "Make Admin" which updates that profileâ€™s role to 'admin' (promoting the user).

This is a basic admin management. You could add "Remove admin" or delete users, etc., similarly.

**Auto-assign admin:** We still need to ensure the first user gets admin. After sign-up, we inserted into profiles with role accordingly. Alternatively, an admin could create new admins as shown. If you prefer not auto-promote first user, you could default everyone to 'user' and manually use your database or an admin panel to promote someone to admin.

Now our app has:
- **AuthContext** providing `session` and `profile.role`.
- **(app) group** protecting main app routes.
- **admin section** accessible only to admins.
- **Admin screens** for managing roles.

In the next section, we'll focus on the appâ€™s visual style â€“ a steampunk theme using Tailwind (NativeWind).

## Steampunk-Themed UI with NativeWind

We want our app to have a unique steampunk aesthetic. This includes color schemes (copper, brass, leather brown, etc.), custom fonts (think Victorian or typewriter style), and possibly textured backgrounds (like metal or parchment). We will use **NativeWind** (Tailwind CSS for React Native) for styling utility classes and theming.

### 4.1 Setting Up Tailwind (NativeWind) in Expo

If you haven't already, install NativeWind and Tailwind CSS:
```bash
npm install nativewind
npm install --save-dev tailwindcss@3.3.2
```
*(NativeWind v4 supports Tailwind 3.3; if using newer Tailwind, ensure NativeWind compatibility.)*

Next, initialize Tailwind config:
```bash
npx tailwindcss init
```
This creates a `tailwind.config.js` in your project. Open it and configure the content paths and theme:
```js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./App.{js,jsx,ts,tsx}",
    "./app/**/*.{js,jsx,ts,tsx}",   // include all files in app directory
    "./components/**/*.{js,jsx,ts,tsx}"
  ],
  theme: {
    extend: {
      colors: {
        // Steampunk color palette
        copper: "#B87333",
        brass: "#D1AF6E",
        leather: "#8B4513",
        parchment: "#F5DEB3",
      },
      fontFamily: {
        // Assuming we have added these fonts in /assets and loaded them
        victorian: "VictorianCustomFont",
        typewriter: "SpecialElite_400Regular", // example from Google Fonts
      }
    }
  },
  plugins: [],
  darkMode: "class", // we'll control dark mode via a class
};
```
We extended the theme with some custom colors and font families. For fonts, you'll need to load them via Expo. For example, using `expo-font` or `@expo-google-fonts`. Let's say we use a Google Font "Special Elite" for a typewriter look:
```bash
npx expo install expo-font @expo-google-fonts/special-elite
```
Then in our root, load fonts (perhaps in a custom `<AppRoot>` or in `AuthProvider`):
```ts
import { useFonts, SpecialElite_400Regular } from '@expo-google-fonts/special-elite';
...
let [fontsLoaded] = useFonts({ SpecialElite_400Regular });
if (!fontsLoaded) {
  return <SplashScreen />; // or some loading indicator
}
```
Once loaded, NativeWind can use "SpecialElite_400Regular" if configured with that name in tailwind.config (we gave it key 'typewriter').

**Configure Babel:** Add NativeWindâ€™s plugin in `babel.config.js`:
```js
module.exports = function(api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
    plugins: ['nativewind/babel'],   // add this line
  };
};
``` 

Also, create a `metro.config.js` at project root (for NativeWind to work with images if needed):
```js
const { getDefaultConfig } = require('expo/metro-config');
module.exports = (async () => {
  const config = await getDefaultConfig(__dirname);
  config.transformer = {
    babelTransformerPath: require.resolve("nativewind/css/transformer"),
  };
  return config;
})();
```
(This ensures Tailwind classes are transformed correctly.)

### 4.2 Steampunk Design Elements

Now let's apply a steampunk style:
- **Colors:** We defined `copper`, `brass`, etc. Use them via classes like `bg-copper`, `text-brass`, etc.
- **Dark/Light mode:** We set `darkMode: "class"` in Tailwind config, meaning if a parent View has class `dark`, all dark: classes apply ([Dark Mode | NativeWind](https://nativewind.dev/core-concepts/dark-mode#:~:text=To%20manualy%20control%20the%20color,enable%20the%20class%20darkMode%20strategy))  We can manually toggle the color scheme. For system default, Expo by default is set to light unless `userInterfaceStyle: "automatic"` in app.json We can allow switching theme manually using `useColorScheme()` from NativeWind ([Dark Mode | NativeWind](https://nativewind.dev/core-concepts/dark-mode#:~:text=import%20,nativewind)) if needed.
- **Fonts:** We have `font-victorian` or `font-typewriter` classes ready to use once fonts loaded. Use them for headings or special text.
- **Background textures:** We cannot directly do CSS `background-image` in React Native, but we can include an Image component absolutely positioned, or use `<ImageBackground>`. Alternatively, set a solid background color like a dark brown (`bg-[#1c1c1c]` as used in auth screens). We might later overlay gear images or such for effect.

**Example styles:**
Let's revisit some components to apply theme:
- SignUpScreen had `bg-[#1c1c1c]` for a dark background. We could replace with `bg-leather` (if leather color is dark enough) or keep a dark neutral and use steampunk accents for buttons.
- Buttons: use `bg-brass` or `bg-copper` with text-black or text-white depending on contrast.
- Text: For headings, use `font-victorian` (assuming loaded) and maybe `text-brass`. For normal text on dark background, `text-parchment` (parchment is a light tan).
- Give some elements an old-style border or frame: Tailwind canâ€™t easily give ornate borders, but we can do `border-2 border-brass` on panels to suggest metallic edging.

We should also handle dark mode if needed:
- Because we set `darkMode: "class"`, we can have style variants like `dark:bg-black` and `dark:text-white` etc. We can switch the class on the root container depending on user preference.

If we want to support a light mode (maybe sepia paper background), we could:
- Define in tailwind: `lightBg: "#F5DEB3"` (parchment) for light mode background, `darkBg: "#1c1c1c"` for dark mode background.
- Then in a parent, toggle class "dark" on/off to switch.

For simplicity, let's assume a mostly dark steampunk theme (like brass on dark leather). We won't deeply implement theme switching here, but just note it's possible to toggle via `colorScheme.set()` ([Dark Mode | NativeWind](https://nativewind.dev/core-concepts/dark-mode#:~:text=import%20,nativewind)) 

**Custom Components styling:** If we create our own components, we can still use className props if we forward them or use `styled` from NativeWind. But in most cases, applying `className="..."` on React Native elements works out of the box with NativeWind.

**Example steampunk styling in code:**

Update our SignUpScreen to be more steampunk:
```jsx
<View className="flex-1 justify-center p-4 bg-leather dark:bg-black">
  <Text className="text-3xl font-victorian text-brass text-center mb-4">Create Account</Text>
  ...
  <TextInput className="bg-parchment text-black mb-2 p-2 rounded border border-brass" ... />
  ...
  <TouchableOpacity className="bg-copper p-2 rounded">
    <Text className="text-black font-bold text-center">Sign Up</Text>
  </TouchableOpacity>
  ...
</View>
```
Here:
- We used `bg-leather` (brown) for background in light mode, and `dark:bg-black` variant (so if dark mode toggled, background becomes black).
- Heading text is using a Victorian font and brass color.
- Inputs have a parchment background (light beige) and brass border.
- Sign Up button is copper with black text (for contrast, since copper is medium bright).

These utility classes make it easy to adjust design without writing stylesheets.

Don't forget to load the custom font and possibly set `userInterfaceStyle: "automatic"` in app.json to allow system dark mode. Also, if you want to allow manual theme toggle, NativeWind docs suggest using `colorScheme.set("dark")` or a context. But given a steampunk theme, we might just stick to one or have a toggle between "Dark Steampunk" and "Light Steampunk (sepia)" modes.

### 4.3 Using NativeWind in Components

Throughout our components (as seen), we use classNames:
- Layout and spacing (e.g., `flex-1 p-4`, `mb-4` for margin-bottom).
- Typography (`text-xl`, `font-typewriter`, `text-center`).
- Colors (`bg-copper`, `text-parchment`).
- Conditional dark mode classes (`dark:bg-black` etc.).

NativeWind processes these at compile-time into RN StyleSheet equivalents, so itâ€™s efficient.

**Tailwind Config Customization:** In addition to colors/fonts, we could add:
- Shadows or textures: Tailwind has `shadow` utilities, e.g., `shadow-xl` for intense drop shadows (could mimic depth).
- We canâ€™t directly embed an image via tailwind, but we can use an Image with style width/height 100% for backgrounds if needed.

Given the steampunk vibe, consider using gear icons or images in the UI. For example, as icons on buttons or background watermark. You might import some PNG/SVG and place them in the layout (with `position: 'absolute'` style via tailwind like `absolute top-0 right-0 opacity-20` for a faint gear in corner).

### 4.4 Dark Mode Support

We already enabled `darkMode: "class"` ([Dark Mode | NativeWind](https://nativewind.dev/core-concepts/dark-mode#:~:text=To%20manualy%20control%20the%20color,enable%20the%20class%20darkMode%20strategy))  If the device is set to dark and Expo is configured to allow auto, the `Appearance.getColorScheme()` in NativeWind will automatically apply the dark variant classes if no manual override 

Expo requires `userInterfaceStyle: "automatic"` in app.json or in code:
```json
"android": { "userInterfaceStyle": "automatic" },
"ios": { "userInterfaceStyle": "automatic" }
```
(This is default usually.)

If you want a manual toggle button in-app:
```tsx
import { useColorScheme } from 'nativewind';
...
const { colorScheme, setColorScheme } = useColorScheme();
return (
  <Switch 
    value={colorScheme === 'dark'} 
    onValueChange={(val) => setColorScheme(val ? 'dark' : 'light')} 
  />
);
```
This would let user flip a switch to set dark or light theme ([Dark Mode | NativeWind](https://nativewind.dev/core-concepts/dark-mode#:~:text=import%20,nativewind))  The `dark:` classes in our components would respond accordingly.

However, for a consistent steampunk feel, you might keep a dark theme by default and not worry about light mode unless desired.

With styling in place, our app should have a distinctive look: custom fonts, thematic colors, and responsive design (Tailwind classes handle different screen sizes with prefixes like `md:` if needed, though mobile-first is often fine).

Next, we'll add social features: user profiles, posts, feed, likes, comments, etc., to make this a mini social network.

## Social Networking Features

This section adds core social features to our app:
- **User Profiles** with avatars and bios.
- **Posting** (creating, editing, deleting posts).
- **Media upload** (photos or videos in posts) via Supabase Storage.
- A **feed** with infinite scroll and real-time updates (new posts appearing live).
- **Likes and Comments** on posts.
- **Notifications** for interactions.
- **Geolocation & Maps** integration for posts with location.

That's a lot, so we'll focus on structure and key code pieces:

### 5.1 Profiles

We already have a `profiles` table for roles. We can extend it to include `username`, `avatar_url`, `bio`, etc. Ensure RLS allows each user to select/update their own profile, and allows all users to view others' profiles (maybe email should be private, but avatar and bio public).

**Profile Screen (`app/(app)/profile.tsx`):**
```tsx
import { useAuth } from '../utils/AuthContext';
import { useState } from 'react';
import { View, Text, TextInput, Image, TouchableOpacity } from 'react-native';
import * as ImagePicker from 'expo-image-picker';
import { supabase } from '../utils/supabase';

export default function ProfileScreen() {
  const { session, profile } = useAuth();
  const user = session?.user;
  // local state for editing profile fields
  const [bio, setBio] = useState<string>(user?.user_metadata.bio || '');
  const [avatarUrl, setAvatarUrl] = useState<string>(user?.user_metadata.avatar_url || '');

  const pickAvatar = async () => {
    let result = await ImagePicker.launchImageLibraryAsync({ mediaTypes: ImagePicker.MediaTypeOptions.Images, quality: 0.7 });
    if (!result.canceled && result.assets.length > 0) {
      const file = result.assets[0];
      // upload to Supabase Storage
      const ext = file.uri.split('.').pop();
      const path = `${user.id}/avatar.${ext}`;
      const { error: uploadError } = await supabase.storage.from('avatars').upload(path, await fetch(file.uri).then(r=>r.blob()), { upsert: true });
      if (!uploadError) {
        const publicUrl = supabase.storage.from('avatars').getPublicUrl(path).data.publicUrl;
        setAvatarUrl(publicUrl);
      }
    }
  };

  const saveProfile = async () => {
    const updates = { bio, avatar_url: avatarUrl };
    await supabase.from('profiles').update(updates).eq('user_id', user.id);
    // Optionally update auth user metadata via supabase.auth.updateUser
    // but storing in profiles is enough since we can fetch from there.
  };

  return (
    <View className="flex-1 p-4">
      {avatarUrl ? (
        <Image source={{ uri: avatarUrl }} style={{ width: 100, height: 100, borderRadius: 50 }} />
      ) : (
        <View className="w-24 h-24 bg-gray-500 rounded-full" />
      )}
      <TouchableOpacity onPress={pickAvatar}>
        <Text className="text-blue-400">Change Avatar</Text>
      </TouchableOpacity>

      <Text className="mt-4 font-bold">Bio:</Text>
      <TextInput
        className="border border-gray-300 p-2"
        multiline
        value={bio} onChangeText={setBio}
      />
      <TouchableOpacity onPress={saveProfile} className="bg-brass p-2 mt-4 rounded">
        <Text className="text-black text-center">Save Profile</Text>
      </TouchableOpacity>
    </View>
  );
}
```
Key points:
- We use Expoâ€™s ImagePicker to let the user choose a new avatar.
- We upload the image to Supabase Storage bucket (e.g., "avatars" bucket). Supabase Storage provides an easy JS API for uploading files ([React Native file upload with Supabase Storage](https://supabase.com/blog/react-native-storage?utm_source=expo&utm_medium=referral&utm_term=expo-react-native#:~:text=Using%20the%20image%20picker%20from,can%20use%20to%20read%20the)) 
- We get a public URL for the uploaded file (for simplicity, we make the bucket public or use `getPublicUrl` â€“ ensure your storage policy allows read if public).
- Save the avatar URL and bio to the `profiles` table. This information can be fetched to display someone's profile or avatar in the feed.

**Note:** In a production scenario, you might want avatars to be public (so others can see them) while some profile info private. You can adjust RLS policies accordingly.

### 5.2 Post Creation and Feed

**Data model:** Create a `posts` table in Supabase with columns: `id (uuid)`, `user_id (uuid ref auth.users)`, `content (text)`, `media_url (text)`, `created_at (timestamp)`, maybe `location (geography point)` if we store geolocation. Enable RLS such that:
- Anyone can `select` posts (if it's a public feed).
- Only the owner (user_id = auth.uid()) can `update` or `delete` their post.
- Only authenticated (role `authenticated`) can `insert` (so guests cannot post).

**Posting UI (`app/(app)/new-post.tsx`):**
```tsx
import { useState } from 'react';
import { View, TextInput, TouchableOpacity, Text, Image } from 'react-native';
import * as ImagePicker from 'expo-image-picker';
import * as Location from 'expo-location';
import { useAuth } from '../utils/AuthContext';
import { supabase } from '../utils/supabase';

export default function NewPostScreen() {
  const { session } = useAuth();
  const [content, setContent] = useState('');
  const [image, setImage] = useState(null);
  const [uploading, setUploading] = useState(false);

  const pickImage = async () => {
    let result = await ImagePicker.launchImageLibraryAsync({ mediaTypes: ImagePicker.MediaTypeOptions.Images });
    if (!result.canceled) {
      setImage(result.assets[0]);
    }
  };

  const handlePost = async () => {
    setUploading(true);
    let mediaUrl = null;
    if (image) {
      // Upload image to 'posts' bucket
      const ext = image.uri.split('.').pop();
      const path = `${session.user.id}/${Date.now()}.${ext}`;
      const { error: uploadError } = await supabase.storage.from('posts').upload(path, await fetch(image.uri).then(r=>r.blob()));
      if (!uploadError) {
        mediaUrl = supabase.storage.from('posts').getPublicUrl(path).data.publicUrl;
      }
    }
    // Get location
    let location = null;
    const perms = await Location.requestForegroundPermissionsAsync();
    if (perms.granted) {
      const loc = await Location.getCurrentPositionAsync({});
      location = loc ? { latitude: loc.coords.latitude, longitude: loc.coords.longitude } : null;
    }
    // Insert post
    const { error } = await supabase.from('posts').insert({
      content,
      media_url: mediaUrl,
      // if location column is a PostGIS point, maybe need to format as `ST_Point(long, lat)`
      // or store as two separate columns for simplicity (latitude, longitude).
      latitude: location?.latitude,
      longitude: location?.longitude
    });
    setUploading(false);
    if (!error) {
      // navigate back to feed or clear form
      router.replace('/(app)'); // assuming (app)/index is feed
    } else {
      console.error(error);
    }
  };

  return (
    <View className="flex-1 p-4">
      {image && <Image source={{ uri: image.uri }} style={{ width: '100%', height: 200 }} />}
      <TouchableOpacity onPress={pickImage} className="p-2 bg-gray-600 rounded mb-2">
        <Text className="text-white">{ image ? "Change Image" : "Pick Image" }</Text>
      </TouchableOpacity>
      <TextInput
        placeholder="What's on your mind?"
        className="border border-gray-400 p-2 mb-2"
        multiline
        value={content} onChangeText={setContent}
      />
      <TouchableOpacity onPress={handlePost} className="bg-copper p-2 rounded" disabled={uploading}>
        <Text className="text-black text-center">{uploading ? "Posting..." : "Post"}</Text>
      </TouchableOpacity>
    </View>
  );
}
```
In this **NewPostScreen**:
- The user can choose an image to attach (using ImagePicker). We store it in state and preview it.
- On post, we upload the image to a Supabase Storage bucket named "posts". 
- We also attempt to get the current geolocation (with permission) using Expo Location. If successful, we capture latitude/longitude.
- We insert a new row in `posts` with content, media URL, and location coordinates.
- After posting, we navigate (or redirect) back to the feed.

Make sure to create the "posts" storage bucket in Supabase and set appropriate policies (maybe public read for images, or use signed URLs and a function to retrieve them).

**Feed Screen (`app/(app)/index.tsx` or a dedicated feed file):**
```tsx
import { useEffect, useState } from 'react';
import { View, Text, Image, FlatList, ActivityIndicator } from 'react-native';
import { Link } from 'expo-router';
import { supabase } from '../utils/supabase';

interface Post { id: string; content: string; media_url: string | null; user_id: string; created_at: string; latitude?: number; longitude?: number; }

export default function FeedScreen() {
  const [posts, setPosts] = useState<Post[]>([]);
  const [loading, setLoading] = useState(true);
  const [from, setFrom] = useState(0);  // for pagination
  const PAGE_SIZE = 10;

  const fetchPosts = async (fromIndex = 0) => {
    const { data, error } = await supabase.from('posts')
      .select('*')
      .order('created_at', { ascending: false })
      .range(fromIndex, fromIndex + PAGE_SIZE - 1);
    if (!error && data) {
      if (fromIndex === 0) setPosts(data);
      else setPosts(prev => [...prev, ...data]);
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchPosts();
    // Subscribe to realtime updates for new posts
    const channel = supabase.channel('public:posts')
      .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'posts' }, payload => {
        const newPost = payload.new as Post;
        setPosts(prev => [newPost, ...prev]);
      })
      .subscribe();
    return () => { supabase.removeChannel(channel); };
  }, []);

  const loadMore = () => {
    if (!loading) {
      setLoading(true);
      const nextFrom = from + PAGE_SIZE;
      setFrom(nextFrom);
      fetchPosts(nextFrom);
    }
  };

  return (
    <View className="flex-1">
      {posts.length === 0 ? (
        loading ? <ActivityIndicator /> : <Text>No posts yet.</Text>
      ) : (
        <FlatList
          data={posts}
          onEndReached={loadMore}
          keyExtractor={(item) => item.id}
          renderItem={({ item }) => (
            <View className="p-4 border-b border-gray-700">
              {/* Display post content */}
              <Text className="text-parchment">{item.content}</Text>
              {item.media_url && 
                <Image source={{ uri: item.media_url }} style={{ width: '100%', height: 200, marginVertical: 8 }} />
              }
              <Link href={`/posts/${item.id}`}>
                <Text className="text-blue-400">View Comments</Text>
              </Link>
            </View>
          )}
          ListFooterComponent={loading ? <ActivityIndicator /> : null}
        />
      )}
    </View>
  );
}
```
Explanation:
- We fetch posts in pages (using `.range()` for pagination). PAGE_SIZE=10 means we fetch 10 at a time.
- The feed is sorted by newest first.
- The state `from` and function `loadMore` handle infinite scroll. When user scrolls to bottom (`onEndReached`), we load the next page.
- We set up a **Realtime subscription** to the `posts` table using Supabase's Realtime channels ([Realtime | Supabase Docs](https://supabase.com/docs/guides/realtime#:~:text=supabase))  On any new insert, we prepend the post to the feed in real-time.
  - Supabase Realtime must be enabled on the `posts` table (via the dashboard, enable for INSERT events) ([Realtime | Supabase Docs](https://supabase.com/docs/guides/realtime#:~:text=supabase)) 
- Each post displays content text, and if there's an image, shows it. (For videos, one could use `Video` component from `expo-av` similarly by providing the URL.)
- There's a link to a Comments screen (we'll create next).
- `ListFooterComponent` shows a spinner when loading more.

This provides an **infinite scrolling feed** and **real-time updates** for new posts. The user can also pull-to-refresh by dragging (FlatList supports onRefresh if needed, not shown here).

### 5.3 Comments and Likes

**Comments:** Create a `comments` table with `id, post_id, user_id, content, created_at`. We can display comments in a separate screen, e.g., `app/(app)/posts/[id].tsx` for a post detail with comments. (We might reuse the dynamic route from our CLI generator, but let's assume we customize it for comments.)

**Post Detail & Comments (`app/(app)/posts/[id].tsx`):**
```tsx
import { useLocalSearchParams } from 'expo-router';
import { useEffect, useState } from 'react';
import { View, Text, TextInput, TouchableOpacity, FlatList } from 'react-native';
import { supabase } from '../../utils/supabase';
import { useAuth } from '../../utils/AuthContext';

export default function PostDetail() {
  const { id } = useLocalSearchParams<{ id: string }>();
  const { session } = useAuth();
  const [post, setPost] = useState(null);
  const [comments, setComments] = useState<any[]>([]);
  const [commentText, setCommentText] = useState('');

  useEffect(() => {
    if (!id) return;
    supabase.from('posts').select('*').eq('id', id).single()
      .then(({ data }) => setPost(data));
    supabase.from('comments').select('id, content, user_id, created_at').eq('post_id', id).order('created_at')
      .then(({ data }) => setComments(data || []));
    // Subscribe to new comments on this post
    const channel = supabase.channel('public:comments')
      .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'comments', filter: `post_id=eq.${id}` },
        payload => setComments(prev => [...prev, payload.new])
      ).subscribe();
    return () => { supabase.removeChannel(channel); };
  }, [id]);

  const sendComment = async () => {
    if (!commentText) return;
    await supabase.from('comments').insert({ post_id: id, content: commentText });
    setCommentText('');
  };

  if (!post) {
    return <Text>Loading...</Text>;
  }
  return (
    <View className="flex-1 p-4">
      <Text className="text-xl mb-2">{post.content}</Text>
      {/* Display post image if any, and maybe a map or location */}
      {post.media_url && <Image source={{ uri: post.media_url }} style={{ width: '100%', height: 200 }} />}
      {post.latitude && post.longitude && (
        <MapView style={{ width: '100%', height: 200 }} 
          initialRegion={{ latitude: post.latitude, longitude: post.longitude, latitudeDelta: 0.01, longitudeDelta: 0.01 }}>
          <Marker coordinate={{ latitude: post.latitude, longitude: post.longitude }} />
        </MapView>
      )}
      <Text className="mt-4 mb-1 font-bold">Comments:</Text>
      <FlatList
        data={comments}
        keyExtractor={item => item.id}
        renderItem={({ item }) => (
          <Text className="mb-1"><Text className="font-bold">{item.user_id}: </Text>{item.content}</Text>
        )}
      />
      <View className="flex-row mt-2">
        <TextInput
          className="flex-1 border border-gray-400 p-2"
          placeholder="Add a comment..."
          value={commentText} onChangeText={setCommentText}
        />
        <TouchableOpacity onPress={sendComment} className="bg-brass p-2 ml-2 rounded">
          <Text>Send</Text>
        </TouchableOpacity>
      </View>
    </View>
  );
}
```
This screen:
- Fetches the post (could also be passed from navigation to avoid extra fetch).
- Fetches all comments for the post.
- Sets up a realtime subscription for new comments on this post (filter by post_id) to update the list immediately when someone comments ([Realtime | Supabase Docs](https://supabase.com/docs/guides/realtime#:~:text=supabase)) 
- Displays comments in a FlatList.
- Allows the user to add a comment via TextInput and send button (inserts into `comments` table).
- It also demonstrates how to show the location on a map: using `react-native-maps`. We include a `<MapView>` and a `<Marker>` pin if the post has coordinates. **Note:** `react-native-maps` requires adding an API key in app.json for release, but in Expo Go it works out of the box Make sure `expo install react-native-maps` was done earlier.

**Likes:** Implementing likes can be done via a separate `likes` table (user_id, post_id). For simplicity, we could allow one like per user per post (primary key or unique constraint on (user_id, post_id)).
- We could display a Like button on each post in the feed or detail screen.
- On press, call supabase RPC or upsert to likes table.
- We might not fully implement here due to brevity, but conceptually:
  - Show a filled or outlined heart icon depending if current user liked (you can fetch if current user liked or maintain in state).
  - Increment like count: could either fetch count via `.select('count', { count: 'exact' })` or maintain a `likes_count` column updated via trigger.

**Notifications:** A simple approach:
- Create `notifications` table: id, user_id (the recipient), type (like, comment, etc.), data (maybe JSON or text like "User X commented on your post"), created_at, read (bool).
- Whenever a like or comment is inserted, you could use a Supabase function or trigger to insert a notification for the postâ€™s owner. For instance, after insert on comments, do:
  ```sql
  insert into notifications(user_id, type, data) values (
    (select user_id from posts where id = NEW.post_id),
    'comment',
    'User ' || NEW.user_id || ' commented on your post'
  );
  ```
  This would notify the post owner.
- The app can subscribe to notifications similarly via realtime or just poll.
- For example, in AuthContext or a NotificationContext, subscribe to `notifications` where user_id = current user and not read.
- Display an icon or list in-app for notifications. Possibly integrate with push notifications (Expo Push) for real-time device notifications, but that's beyond scope here.

**Geolocation & Maps:** We already integrated basic location capturing for posts and display on a map:
- We used Expo Location to get coordinates (ensuring permission).
- We displayed a MapView with a Marker for the post location. You might also add a link to open in external map app or show distance between user and post, etc.
- If you want a global map of posts (like an "Explore Map"), you could have a screen with a MapView that plots all posts with markers (fetch posts with coordinates and map them to markers).
- Using `react-native-maps`, ensure to use Google Maps API key for Android in production by adding in app.json as per Expo docs

That covers our social features: profile management, posting with media and location, feed with infinite scroll and realtime updates, commenting, (likes conceptually), and notifications conceptually. There are many details you can expand (like editing posts, which could reuse the NewPost screen by pre-filling content if you navigate with post data and update instead of insert).

Next, we tie things together with the global app architecture and providers, ensuring our navigation and contexts are set up properly.

## Global Architecture and Provider Setup

In this section, we'll discuss how to organize the app's structure and providers at a global level. We've touched on it already:
- Using Expo Router with a root layout.
- Wrapping the app with context providers (AuthProvider, and possibly a ThemeProvider if needed).
- Ensuring our navigation structure (stacks, tabs, etc.) is set up.

### 6.1 Project Structure Recap

Our project structure might look like:
```
app/
  _layout.tsx        // Root layout including providers
  sign-in.tsx
  sign-up.tsx
  (app)/
    _layout.tsx      // Auth-protected layout
    index.tsx        // Feed screen (for example)
    new-post.tsx
    profile.tsx
    admin/
      _layout.tsx    // Admin-protected layout
      index.tsx      // Admin dashboard
      users.tsx      // Manage users
    posts/
      [id].tsx       // Post detail & comments
      _layout.tsx    // (optional, if needed for nested nav)
    ... other modules (e.g., from CLI generator)
components/
  ... (common components like custom buttons or headers)
utils/
  supabase.ts
  AuthContext.tsx
  ...
```
We modularized features: all screens that require auth are under `(app)`, admin under `admin`, etc., keeping separation of concerns.

### 6.2 Root Layout with Providers

Expo Router requires an `app/_layout.tsx` that functions like the root App component We will use it to inject our context providers (AuthProvider for sure, possibly others like a Theme or Notification provider).

**app/_layout.tsx:**
```tsx
import { Stack } from 'expo-router';
import { AuthProvider } from '../utils/AuthContext';

export default function RootLayout() {
  return (
    <AuthProvider>
      <Stack screenOptions={{ headerShown: false }} />
    </AuthProvider>
  );
}
```
This wraps the entire navigation stack in `AuthProvider`. Now any route can use `useAuth()`. We turned off headers globally for simplicity (`headerShown: false`), because we might design our own headers or use context to display different things. You can adjust screenOptions or use separate layouts in groups to have different header styles (e.g., maybe show a header in the admin screens only).

Inside `<Stack>` we could also define some common screen options or use `<Tabs>` if we wanted a tab bar. For example, we could use a tab navigator for main app (feed tab, profile tab, etc.). Expo Router can do nested navigators via layouts:
- Use `<Tabs>` component in `app/(app)/_layout.tsx` to create a tab bar for all child routes.
- Or use multiple groups: e.g., `app/(app)/feed.tsx`, `app/(app)/profile.tsx` and an `app/(app)/_layout.tsx` returning `<Tabs>` with two screens: feed and profile.

Given our structure, we kept it simple with Stack and linking manually. But one can refine it as needed.

**Multiple Providers:** If we had a ThemeProvider (for toggling dark mode) or other context, we could nest providers:
```jsx
<AuthProvider>
  <ThemeProvider>
    <Stack ... />
  </ThemeProvider>
</AuthProvider>
```
Just ensure the order (AuthProvider likely first if ThemeProvider might not need auth context, etc.).

### 6.3 State Management

We are using React Context for auth. This is fine for global user state. For other state, we've mostly kept it local to components (feed posts state, etc.). One could use a global state library if needed (Redux, Zustand, etc.), but this simple approach works for our use-case:
- Auth & user info via context.
- Everything else fetches from Supabase on mount or uses component-level state.

If you find yourself passing props down many levels, consider additional contexts or using Expo Router's route parameters to pass data between screens.

### 6.4 Navigation Considerations

With Expo Router, navigation is mostly via `<Link>` components or imperative `useRouter().push()`. We used `<Link>` for simplicity in many places. This is like web navigation. It works nicely especially when your routes are defined via files.

We should also consider a "Not Found" route for any undefined paths. Expo Router supports a special file `app/_layout.tsx` and `app/_layout/not-found.tsx` or similarly a top-level `app/[...missing].tsx`. But for our app, users won't manually type paths, so it's minor.

One more consideration: **Deep Linking for Auth** â€“ we already set scheme and handled OAuth. If we wanted, say, email magic links or other deep links, we would also ensure our app can handle those via routes or `Linking.addEventListener`. Supabase sends magic links to a URL like `myapp://login...`. We covered OAuth scenario sufficiently.

### 6.5 Providers for Theming or Other Global State

**Theming:** If we want to let user toggle the steampunk theme (maybe a sepia mode vs dark mode), we could create a ThemeContext that uses `useColorScheme()` under the hood. NativeWind does provide `useColorScheme` hook which we used. Actually, we might not need a separate context if using that hook. But if we had other theme elements (like toggling font size globally), we could manage that similarly.

**Notifications:** We might create a context to fetch notifications count and provide a function to mark them read. Or simply fetch in a notifications screen. A context could use Supabase channel for notifications similar to how we did for posts.

**Expo Systems:** For completeness, consider adding:
- **Expo Updates** if you want OTA updates (config in app.json).
- **Push Notifications** with `expo-notifications` (would require userâ€™s push token and a server or Supabase function to send notifications).
- **Error Boundary**: Expo Router supports an error file at each level (e.g., `app/_layout.tsx` could catch errors in child screens). You can create `app/_layout.error.tsx` to display something if any child throws an error. In our code, we mostly handle errors via state and console logs, but an error boundary is a nice safety net. Expo will render that if a component throws.

Now, let's touch on how we handle Supabase data and security beyond what we've done, to ensure best practices on the backend side.

## Supabase Data Management & Security

We have used Supabase for auth, storage, and database. To ensure a robust app, we should configure Supabase correctly:
- **Realtime**: Already enabled for posts and comments via `supabase.channel(...)` in our code. On the Supabase dashboard, one must enable the `posts` and `comments` tables in the Realtime settings (under Database > Replication (Publications)) Usually enabling for all INSERT/UPDATE/DELETE events on those tables to the `supabase_realtime` publication is what triggers our listeners ([Realtime | Supabase Docs](https://supabase.com/docs/guides/realtime#:~:text=From%20the%20client%2C%20we%20can,table)) 
- **Row Level Security (RLS)**: We should write policies for each table:
  - `profiles`: 
    - Select: `true` for all authenticated so users can see others' basic profiles (or restrict certain columns).
    - Update: allow when `user_id = auth.uid()` or if auth.role() is 'authenticated' (since all authed are 'authenticated') but that would allow anyone to update anyone's profile, so better: `using (user_id = auth.uid())` for update.
    - Insert: allow when `user_id = auth.uid()` to allow creating your own profile.
    - Maybe a separate policy: allow admins (we stored role in table, but Supabase doesn't inherently know that; you could do subquery check as mentioned).
  - `posts`:
    - Select: `role = authenticated` (so only logged-in can read posts, or allow anon if public? Up to you).
    - Insert: `auth.uid() != NULL` (any logged-in user can insert).
    - Update: `user_id = auth.uid()` (only author can edit).
    - Delete: `user_id = auth.uid()` or admin can delete maybe (you could allow if auth.uid() in (select user_id from profiles where role='admin')).
  - `comments`:
    - Similar to posts: anyone logged in can insert, owners can delete/edit their own.
    - Select: probably allow all authenticated to read (so they can see comments on posts).
  - `likes`: 
    - Insert: user can like (maybe allow if not already liked; could enforce unique via constraint).
    - Delete: user can remove their like.
    - Select: allow all authed to get likes (for counts).
  - `notifications`:
    - Select: only recipient can read (`user_id = auth.uid()`).
    - Insert: perhaps via a backend function; or allow anyone to insert a notification where user_id = that user's ID? (Better to have a secure function or only allow via trigger on like/comment as mentioned.)
    - Update: allow marking read if `user_id = auth.uid()`.

Because our client uses the anon public key, these RLS rules must allow the needed operations or you'll get errors. We recommended in code where certain data requires admin powers, to use RLS to secure it too. For example, in `ManageUsers`, we fetch all profiles. A normal user wouldn't be allowed to select all. So a policy: 
```sql
-- Allow admin to select all profiles
create policy "Admin can view all profiles"
on profiles for select
using (
  (select role from profiles where user_id = auth.uid()) = 'admin'
);
```
This means if the requesting user (auth.uid()) has role 'admin' in their profile, then any row is visible (since using returns true unconditionally for them). Non-admins would fall to maybe another policy that only allows selecting their own profile.

Similar policy for update on profiles to allow admin to update (promote others).

**Supabase Edge Functions:** As an advanced note, if some logic is too complex (like first-user admin assignment), you could implement a Supabase Edge Function in JavaScript that runs on certain events or is called from client with service key. For instance, a signup trigger could call a function to assign role. This is beyond our immediate scope but worth exploring for production.

**Data-fetching utilities aligned with schema:** We mostly used supabase queries inline. In a larger project, you might abstract some of those:
- E.g., a `api.ts` file with functions like `getPosts(page)`, `createPost(data)`, `likePost(postId)`, etc. This centralizes Supabase calls and makes it easier to handle errors or adjustments in one place.
- We might also generate TypeScript types for our tables. Supabase can provide types via its codegen or one can define interfaces manually (like we did for Post, not strictly typed from Supabase). Using these ensures type safety on data.

**Performance considerations:** Supabase can send a lot of data if not careful. Use `.select('fields')` to limit columns if needed, and pagination for lists. We used `.range()` for feed. For comments, if a post has thousands, consider pagination or lazy loading old comments.

**Storage Security:** If your storage buckets are public (we used getPublicUrl which implies public bucket), then anyone with URL can view the file. If thatâ€™s a concern (maybe for user privacy), use restricted bucket and generate signed URLs on demand. Supabaseâ€™s JS library can create signed URLs with an expiry. That way, only authorized users (with a valid JWT) can get a short-lived link to the image. For our case, avatars and post images can be considered semi-public, so it's okay.

**Cleaning up**: Maybe set rules or triggers to delete comments/likes if post is deleted, or storage files if post is deleted, etc., to avoid orphan files.

We have now built the core features. Finally, let's cover documentation and best practices to ensure maintainability.

## Documentation & Best Practices

Building a framework or complex app requires maintaining code quality and clarity:
- **Coding Standards:** Decide on a style guide (semi vs no-semi, quotes, etc.) and use tools:
  - **ESLint**: Initialize an ESLint config (Expo template often includes one). Linting will catch common mistakes.
  - **Prettier**: Use for consistent formatting. You can add a script or editor config to format on save.
  - Use meaningful naming conventions (we named files by feature, e.g., `ManageUsers` component, etc., which is okay). Stick to either camelCase or PascalCase for file names consistently (React often uses PascalCase for component files).
  - Organize code into logical modules (we separated `utils`, could also have `hooks/`, `services/` etc. as app grows).

- **Comments and Docs:** Write comments in code where non-obvious logic occurs (like tricky auth flows). Also, maintain a README (this tutorial could serve as one) to help future contributors (or your future self).

- **Testing Strategies:**
  - Unit test critical logic that can be isolated (e.g., a function that formats data or a context reducer if any).
  - For authentication and API calls, you can use integration tests or mocks. Since supabase is an external service, for unit tests you might mock supabase client methods to simulate login, etc.
  - Use `jest-expo` for testing React Native components It has presets to handle RN components.
  - Write tests for:
    - AuthContext (e.g., ensure it sets session correctly on login event).
    - The CLI generator (you can test that given a sample XAML, correct files are created).
    - Components: e.g., test that `ManageUsers` shows an "Make Admin" button for non-admin users.
  - End-to-end testing: you can use Detox or Appium for RN to simulate user flows (advanced).
  - Also test on both platforms (iOS/Android) to catch any platform-specific issues.

- **Error Handling:**
  - We tried to handle errors from Supabase (logging or showing message). Ensure every supabase call checks `error` and handles it (we did in many places).
  - Perhaps create a centralized error toast system: e.g., a Context or simply use Expoâ€™s `ToastAndroid` or a custom <Snackbar> component to show errors globally.
  - Use try/catch around critical sections (like image upload, location fetch) and inform the user if something goes wrong (e.g., "Image upload failed, please try again").
  - For network errors, supabase-js will return an `error` object; you can inspect or simply show `error.message`.
  - Consider offline handling if needed: right now, if offline, these supabase calls fail. A more advanced approach could queue actions for later or use a caching layer (outside scope, but Supabase + something like Redux persist or SQLite could be considered).
  
- **Performance & Optimizations:**
  - Use React.memo or similar if you notice re-renders heavy, but likely fine.
  - Possibly use FlatList optimizations (like keyExtractor, and avoid arrow functions in renderItem by defining a separate component).
  - Image loading: for better performance, use proper sizes or even thumbnails. Expo has `ImageManipulator` or you can store thumbnails in DB.

- **Security:**
  - We covered RLS and not exposing keys except anon.
  - Ensure no sensitive data is in repo (like we wouldn't commit service_role key).
  - Possibly implement rate limiting on certain actions (Supabase has built-in rate limit for auth attempts.
  - Use secure connections (Supabase endpoints are HTTPS by default).
  - Keep dependencies updated (especially if any security fixes in them).
  
- **Continuous Integration:** If this is a project with multiple devs, set up CI to run tests and perhaps lint on pull requests. Expo apps can be built via EAS, so maybe integrate that for releasing.

- **Modularity:** Our framework allows adding new modules via the CLI. Document how to use the CLI (e.g., run `npm run gen-module -- path/to/config.xaml`). Consider edge cases: if run twice for same module, should it overwrite or skip? Possibly add a confirmation or unique check.

- **Future improvements:**
  - Perhaps abstracting the CLI to be more generic or publishing it as an NPM package.
  - Adding more screen templates (for charts, or different layouts).
  - Internationalization (i18n) if needed for multiple languages.
  - Accessibility: ensure components have accessibility props where necessary (React Native accessibilityLabel, etc., for screen readers).

This documentation and following best practices will make your project easier to maintain and scale.

Finally, as promised, let's provide a script to automate the initial project setup, which ties many of these steps together.

## Automation Scripts for Project Setup

To streamline starting a new project with this framework, we can use a shell script. This script will:
- Initialize a new Expo project (with TypeScript).
- Install all required dependencies (Expo Router, NativeWind/Tailwind, Supabase, etc.).
- Create config files (tailwind.config.js, babel.config.js modifications, etc.).
- Scaffold basic directories and example files (like AuthContext, a sample screen structure, etc.).

**setup.sh** (bash script example):

```bash
#!/bin/bash

# 1. Create new Expo project with TypeScript template
read -p "Enter your project name: " PROJECT_NAME
npx create-expo-app "$PROJECT_NAME" -t expo-template-blank-typescript
cd "$PROJECT_NAME" || { echo "Failed to cd into project"; exit 1; }

# 2. Install dependencies
echo "Installing dependencies..."
# Expo Router and related
npx expo install expo-router react-native-safe-area-context react-native-screens expo-linking expo-constants expo-status-bar react-native-gesture-handler
# Supabase and auth utilities
npx expo install @supabase/supabase-js @react-native-async-storage/async-storage react-native-url-polyfill expo-auth-session
# NativeWind and Tailwind
npm install nativewind
npm install --save-dev tailwindcss@3.3.2
# React Native Maps and Location
npx expo install react-native-maps expo-location
# Expo Font (for custom fonts, optional)
npx expo install expo-font

# 3. Configure Expo Router entry
echo "Configuring Expo Router..."
# Add main entry in package.json
npx json -I -f package.json -e 'this.main="expo-router/entry"'
# Add expo-router plugin (if needed for linking bug, optional)
npx json -I -f app.json -e 'this.expo.plugins=["expo-router"]'
# Add scheme for deep linking in app.json
npx json -I -f app.json -e 'this.expo.scheme="com.myapp"'

# 4. Initialize Tailwind config
npx tailwindcss init
# Replace content in tailwind.config.js
sed -i "" "s/content: \[\]/content: [\".\/App.{js,jsx,ts,tsx}\", \".\/app\/**\/*.{js,jsx,ts,tsx}\"]/" tailwind.config.js
# Add steampunk theme to tailwind.config.js (colors, etc.)
sed -i "" "/theme: {/a\\
    extend: {\\
      colors: { copper: \"#B87333\", brass: \"#D1AF6E\", leather: \"#8B4513\", parchment: \"#F5DEB3\" },\\
      fontFamily: { victorian: \"VictorianCustomFont\", typewriter: \"SpecialElite_400Regular\" }\\
    },\\
" tailwind.config.js
# Enable dark mode class strategy
sed -i "" "/module.exports = {/a\\
  darkMode: \"class\",\\
" tailwind.config.js

# 5. Modify babel.config.js to add NativeWind plugin
sed -i "" "/preset: \[\"babel-preset-expo\"\]/a\\
      plugins: [\"nativewind/babel\"],\\
" babel.config.js

# 6. Create directories
mkdir -p app/(app)/admin app/(app)/posts utils components

# 7. Create AuthContext file
cat > utils/AuthContext.tsx << 'EOF'
import { createContext, useContext, useEffect, useState } from 'react';
import { supabase } from './supabase';
import type { Session } from '@supabase/supabase-js';

interface Profile { role: string | null; }
interface AuthContextType {
  session: Session | null;
  profile: Profile | null;
  signOut: () => void;
}
const AuthContext = createContext<AuthContextType|undefined>(undefined);
export function AuthProvider({ children }) {
  const [session, setSession] = useState<Session|null>(null);
  const [profile, setProfile] = useState<Profile|null>(null);
  useEffect(() => {
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session);
      if (session) loadProfile(session);
    });
    const { data: sub } = supabase.auth.onAuthStateChange((event, session) => {
      setSession(session);
      if (session) loadProfile(session);
      else setProfile(null);
    });
    return () => sub.subscription.unsubscribe();
  }, []);
  const loadProfile = async (session: Session) => {
    const { data } = await supabase.from('profiles').select('role').eq('user_id', session.user.id).single();
    setProfile({ role: data?.role || null });
  };
  const signOut = async () => { await supabase.auth.signOut(); };
  return <AuthContext.Provider value={{ session, profile, signOut }}>{children}</AuthContext.Provider>;
}
export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) throw new Error('useAuth must be used within AuthProvider');
  return context;
}
EOF

# 8. Create Supabase init file
cat > utils/supabase.ts << 'EOF'
import 'react-native-url-polyfill/auto';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { createClient } from '@supabase/supabase-js';

const SUPABASE_URL = 'https://YOUR_PROJECT.supabase.co';
const SUPABASE_ANON_KEY = 'YOUR_ANON_KEY';

export const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
  auth: { storage: AsyncStorage, autoRefreshToken: true, persistSession: true, detectSessionInUrl: false }
});
EOF

# 9. Create basic screens (Sign In, Sign Up, RootLayout, Protected layouts)
cat > app/_layout.tsx << 'EOF'
import { Stack } from 'expo-router';
import { AuthProvider } from '../utils/AuthContext';
export default function RootLayout() {
  return (
    <AuthProvider>
      <Stack screenOptions={{ headerShown: false }} />
    </AuthProvider>
  );
}
EOF

cat > app/sign-in.tsx << 'EOF'
import { useState } from 'react';
import { View, Text, TextInput, TouchableOpacity } from 'react-native';
import { Link, useRouter } from 'expo-router';
import { supabase } from '../utils/supabase';

export default function SignIn() {
  const router = useRouter();
  const [email, setEmail] = useState(''); 
  const [password, setPassword] = useState('');
  const [error, setError] = useState(null);
  const handleSignIn = async () => {
    setError(null);
    const { error } = await supabase.auth.signInWithPassword({ email, password });
    if (error) setError(error.message);
    else router.replace('/(app)');
  };
  return (
    <View className="flex-1 justify-center p-4 bg-leather">
      <Text className="text-3xl font-victorian text-brass text-center mb-4">Welcome Back</Text>
      {error && <Text className="text-red-500 mb-2">{error}</Text>}
      <TextInput placeholder="Email" className="bg-parchment mb-2 p-2" autoCapitalize="none" value={email} onChangeText={setEmail} />
      <TextInput placeholder="Password" className="bg-parchment mb-4 p-2" secureTextEntry value={password} onChangeText={setPassword} />
      <TouchableOpacity onPress={handleSignIn} className="bg-copper p-2 rounded"><Text className="text-black text-center">Sign In</Text></TouchableOpacity>
      <Text className="text-center text-parchment mt-4">No account? <Link href="/sign-up"><Text className="text-blue-400">Sign Up</Text></Link></Text>
    </View>
  );
}
EOF

cat > app/sign-up.tsx << 'EOF'
import { useState } from 'react';
import { View, Text, TextInput, TouchableOpacity } from 'react-native';
import { Link, useRouter } from 'expo-router';
import { supabase } from '../utils/supabase';

export default function SignUp() {
  const router = useRouter();
  const [email, setEmail] = useState(''); 
  const [password, setPassword] = useState('');
  const [error, setError] = useState(null);
  const handleSignUp = async () => {
    setError(null);
    const { error } = await supabase.auth.signUp({ email, password });
    if (error) setError(error.message);
    else router.replace('/(app)');
  };
  return (
    <View className="flex-1 justify-center p-4 bg-leather">
      <Text className="text-3xl font-victorian text-brass text-center mb-4">Create Account</Text>
      {error && <Text className="text-red-500 mb-2">{error}</Text>}
      <TextInput placeholder="Email" className="bg-parchment mb-2 p-2" autoCapitalize="none" value={email} onChangeText={setEmail} />
      <TextInput placeholder="Password" className="bg-parchment mb-4 p-2" secureTextEntry value={password} onChangeText={setPassword} />
      <TouchableOpacity onPress={handleSignUp} className="bg-copper p-2 rounded"><Text className="text-black text-center">Sign Up</Text></TouchableOpacity>
      <Text className="text-center text-parchment mt-4">Have an account? <Link href="/sign-in"><Text className="text-blue-400">Sign In</Text></Link></Text>
    </View>
  );
}
EOF

cat > app/(app)/_layout.tsx << 'EOF'
import { Stack, Redirect } from 'expo-router';
import { useAuth } from '../../utils/AuthContext';
export default function AppLayout() {
  const { session } = useAuth();
  if (!session) {
    return <Redirect href="/sign-in" />;
  }
  return <Stack />;
}
EOF

cat > app/(app)/admin/_layout.tsx << 'EOF'
import { Stack, Redirect } from 'expo-router';
import { useAuth } from '../../../utils/AuthContext';
export default function AdminLayout() {
  const { profile } = useAuth();
  if (profile?.role !== 'admin') {
    return <Redirect href="/"/>; 
  }
  return <Stack />;
}
EOF

# 10. Final message
echo "Project $PROJECT_NAME initialized. Don't forget to update supabase.ts with your Supabase URL and anon key, and configure Supabase (DB schema, storage, etc.) accordingly. Happy coding!"
```

Let's break down what this script does:
- It prompts for a project name and uses `create-expo-app` with a TypeScript template.
- Installs all needed packages with appropriate `expo install` or `npm install` for dev dependencies.
- Configures Expo Router by setting the main entry in package.json and adding a scheme in app.json for deep linking ([Install Expo Router - Expo Documentation](https://docs.expo.dev/router/installation/#:~:text=For%20the%20property%20,js))  ([Install Expo Router - Expo Documentation](https://docs.expo.dev/router/installation/#:~:text=Add%20a%20deep%20linking%20,in%20your%20app%20config)) 
- Initializes Tailwind and modifies the config to include our directories and theme customizations for the steampunk look (colors, fonts, dark mode).
- Adds NativeWind Babel plugin in babel.config.
- Creates directory structure for app, including protected groups.
- Generates an AuthContext file and Supabase init file with placeholders for keys (so the developer can insert their actual Supabase credentials).
- Generates basic screens: sign-in, sign-up, root layout, app layout, admin layout. These screens use the styling and structure we described earlier, ready to run.
- Finally, reminds to put the real Supabase keys and set up the backend.

After running this script, the developer can run `npm start` (expo start) and have a nearly functional app. They will still need to:
- Setup Supabase (create tables: profiles, posts, comments, etc., with RLS and maybe some initial data).
- Insert their actual Supabase project URL and anon key into `utils/supabase.ts`.
- Possibly adjust styling or add more screens/modules as needed.

This automation ensures a consistent starting point for any new app based on this framework.

---

**Conclusion:** We've now covered, in detail, how to build an Expo-based application framework with:
- Automated module generation via CLI,
- Supabase authentication (email/password + OAuth with deep linking),
- Role-based access control with an admin panel,
- A themed UI using Tailwind (NativeWind) for a steampunk aesthetic,
- Social features (profiles, posts with media and location, realtime feed, comments, likes, notifications),
- A structured architecture with global providers and secure data handling,
- Best practices for coding and testing,
- A setup script to tie it all together.

Using this tutorial, you should be able to scaffold a new project and incrementally add features, confident that the foundation (authentication, navigation, styling, backend integration) is solid. Good luck building your Expo app! 

